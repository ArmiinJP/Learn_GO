
import "strings"	--> strings.Replace()
import "strings"	--> strings.ToLower()
improt "strings"	--> strings.Split(string, "Delimiter")
import "errors" 	--> errors.New("your messge")
import "fmt"		--> fmt.Errorf("your messge")
import "fmt"		--> fmt.Sprint(VAR) تبدیل هر تایپی به رشته
import "strconv"	--> strconv.Itoa(num) تبدیل دیجیت به رشته
import "strconv"	--> strconv.Atoi(string) تبدیل رشته به دیجیت
import "math"		--> math.Mod(num1, num2) محاسبه باقی‌مانده
import "flag"		--> flag.String()
import "flag"		--> flag.Int()
import "flag"		--> flag.Parse()
import "os"			--> os.Args 
import "os"			--> os.Exit
import "log"		--> log.Fatalf


-------------------------------------------------------------------------------
|^^^| features
نسخه‌ی یک go سال ۲۰۱۲ ریلیز شد و پایبند بوده تا کنون به این.
تغییرات زبان که کم باشه خوبه
بحث backward compatible بودن زبان go خیلی مهم هست. تا زمانی که داره هی رو ورژن‌های 1. کار میکنه میتونه تمامی کدهایی که قبلا روی ورژن یک زده شدند را ساپورت کنه.

گولنگ یک زبان type safe هست، یعنی هر متغیر باید نوعش کاملا واضح و مشخص باشه. یعنی نیمیتونیم متغیری تعریف کنی که تایپش معلوم نیست چی هست.

گولنگ یک سری کد برای زمان اجرا یا کدهای runtime میاد به برنامه اضافه میکنه وقتی شما  build میکنید، و نسخه‌ی اجرایی که آماده میشه، عملا حجیم میشه به واسطه‌ همین کدهای زمان اجرا که بهش attach میشه.

بلاک‌ها با { شروع و با } پایان پیدا می‌کنند. بلاکها مشخص کننده‌ی life time متغیر‌ها هستند. یعنی اگر شما متغیری داخل یک بلاک تعریف کردی، اون متغیر صرفا داخل اون بلاک و تمام بلاکهای داخلیش قابل دسترسی می‌باشد.


وقتی متغیر یا پکیچ تعریف کردید ولی میخواید استفاده نکنید، اصن تعریفش نکنید. و گرنه کامپایلر golang ارور میگیره.

finish
-------------------------------------------------------------------------------
|^^^| compiler & build:
÷÷÷÷÷÷÷÷÷ یک زبان کامپایلری : مترجم زبان سطح بالا به زبان سطح پایین
به یک سری instruction برای ماشین تبدیل میکنه و ماشین دونه دونه این instruction ها را میاد اجرا میکنه

برنامه‌های کامپایلری از قبل به زبان ماشین تبدیل میشن و وقتی میخوایم اجرا کنیم پشت هم این دستورات هستند که اجرا میشند.
اما مفسری ها حین اجرا شروع میکنند به تفسیر کردن به زبان ماشین، و از قبل این تبدیل زبانه صورت نگرفته.

÷÷÷÷÷÷÷÷÷ چند نکته‌ی صدا زدن کامپایلر:
go.mod file
go mod init command
command = giving it the name of the module your code will be in. The name is the module's module path.
go run .
go mod tidy :When you ran go mod tidy, it located and downloaded the HASAN module that contains the package you imported.

go build -o OUTPUT HASAN.go
go run HASAN.go
در گولنگ برای اینکه کار راحتتر بشه و نخوایم هر بار بیلد بگیریم بعد فایل حاصل شده را اجرا کنیم، یه کامند جدید گذاشته که کد را هم build میکنه و هم اجرا میکنه	، البته خب دیگه دسترسی به فایل اجرایی مجزا نداری. دو مرحله‌ را تبدیل به یک مرحله میکنه

÷÷÷÷÷÷÷÷÷ تفاوت go run , go build ببین همینطوری که گفتیم خب go run مستقیما میاد برنامه تو را اجرا میکنه، اما در عمل واقعا میاد خودش اول مثل همون go build ما کامپایل میکنه، فایل اجرایی که بدست اومد که در مکانی از پیش تعریف شده برای خودش هست، میاد اون را اجرا میکنه، در واقع نکته ای که وجود داره در عمل go run از لحاظ عملکردی با go build و بعد هم اجرای فایل باینری که خودمون انجام میدیم تفاوتی نداره، و اون هم اول میاد کامپایل میکنه و بعد فایل اجرایی را اجرا میکنه، فقط چون خودمون لازم نیست دو تا کامند بزنیم کار ما را سریعتر میکنه، ضمنا در محیط پروداکشن ما هیج وقت از go run استفاده نمیکنیم، یعنی نمیایم کد اصلی را برداریم ببریم تو یه سیستم و بعد تازه go run بزنیم که اون هم در عمل در پشت قضیه اول بخواد کامپایل کنه و بعد اجرا، بلکه ما همیشه از کدمون go build میگیریم و وقتی که کامپایل شد حالا دیگه  فایل اجرایی را داریم، و این فایل و برمیداریم در سرور اجراش میکنیم.
فقط توجه کن که خب پیدا کردن فایلی که GO run در عمل میسازه کار راحتیه، بعد که نگاه کنی میبینی حجمش با حجم فایل کامپایل شده‌ی خودت با go build متفاوت هست، اینجا این نکته را باید توجه کنی که احتمالا داره از یک سری optimaztion ها استفاده میکنه که قابل تامل خواهد بود.
توضیحات این بخش در ابتدای فیلم جلسه‌ی ۶ بود


finish
-------------------------------------------------------------------------------
|^^^| file structure:

÷÷÷÷÷÷÷÷÷ نام پکیج باید برای همه‌ی فایل‌های داخل یک پوشه یکسان باشد.

÷÷÷÷÷÷÷÷÷ اما workspace یک پوشه است، و  در واقع راه حل گولنگ برای سازماندهی پروژه‌ها
معمولا همه‌ی پروژه ها در یک workspace نگهداری می‌شوند، برای تعیین workspace از متغیر محلی GOPATH استفاده میشود
به شکل خودکار این متغیر مقدار دهی میشه، و در لینوکس go/~ هستش، با این حال میتونید با دستور go env پیداش کنید و مقدارشو ببینید.
پوشه src برای مدیریت کدها
پوشه‌ی pkg برای ذخیره کردن فایل‌های غیر اجرایی و کتابخانه‌های اشتراکی
پوشه‌ی bin برای ذخیره کردن برنامه‌های اجرایی نوشته شده با golang. در واقع چیزایی که با go install بعدا نصب میکنیم میان اینجا

÷÷÷÷÷÷÷÷÷ شما وقتی میخوای یه پروزه بسازی، میای یک دایرکتوری میسازی، تو این دایرکتوری اول از همه دستور go mod init ESM را میزنی، ESM ای که تعیین میکنی، به تو کمک خواهد کرد که بعدا که میخوای پکیجهای مختلف را صدا بزنی از این اسم به عنوان شروع مسیر استفاده کنی. 
سپس بیا main.go یا هر اسم دیگه‌ای را داخل همین دایرکتوری اصلی بساز و داخلش package main , func main را بزار، در کنار این فایل go میتونی فایلهای goی دیگه‌ای هم که مدنظرت هست را بزاری ولی همشون جز pacakge main خواهند بود. البته به جز یک فایل که در واقع اسمش هم main.go هست دیگه خیلی مرسوم نیست با این حال مشکلی نداری برای ایجاد.
حالا اگه خواستی کدهاتو خارج main بزنی، میتونی به راحتی پوشه‌های جدیدی را داخل این مسیر ایجاد کنی.
ببین این نکته را توجه کن که هر چند تا فایل go ای که میخوای داخل هر پوشه‌ای میتونی قرار بدی، اینها همه با هم بعدا به شکل واحد بهشون نگاه میشه ، متغیر یا تابع همنام نمیتونی براشون تعیین کنی و این جدا کردن چند تا فایل go داخل یک پوشه صرفا برای تمیز شدن هست ولی تو باید کلشون را یک فایل go ببینی و برای همین متغیر تکراری یا تابع تکراری نمیتونی تعریف کنی، (اینکه چطوری چند تا فایل go داخل یک پوشه که همه جز یک پکیج هستند همدیگه را میبینن یا اصن شدنی هست یا نه را نمیدونم). ولی همه‌ی اونهایی که توی یک پوشه هستند باید اسم پکیجشون یکسان باشه، اسم پکیج هم میتونه اسم دایرکتوری نباشه اما دقت کن اگه بعدا خواستی این دایرکتوری و بهتر بگم پکیج را که شامل این فایلهای go هست فراخوانی کنی باید:
import YE_chizi Esm_go_mod/.../Esm_dir
YE_chizi.func...
در واقع اگر اسم پکیجی که برای فایلهای go داخل یک دایرکتوری به کار بردی با اسم دایرکتوریشون متفاوت بود، خود go در واقع یک alies انجام میده و در واقع فایلهای اون مسیر و با اسم پکیجشون میبینه و تو هم موقع import باید مسییر دایرکتوری را بدی ولی قبلش برای راحتی یک alies براش تعریف کنی Ye_chizi که در واقع اسم پکیج عملا جای این قرار خواهد گرفت و بعد هم هر موقع خواستی تابعی فراخوانی کنی باید از این alies و سپس دات استفاده کنی. البته در نظر بگیر که میتونی alies هم ست نکنی ولی اگه خواستی دسترسی بگیری حتما باید با اسم پکیج دسترسی بگیری. 
نکته‌ی بعدی این هست که اسم فایلهای go داخل یک دایرکتوری هیچ اهمیتی نداره، شما وقتی یک پکیج را که شامل چندین فایل go هست import میکنی، کامپایلر همه‌ی این فایلهای go را همونطرو که بالا گفتم انگار میاد با هم به یک چشم نگاه میکنه، یعنی عملا همه‌ی فایلهایی که داخل یک پکیج هستند ، با هم هستند و بعد دات که میزاری، عملا دیگه به تمام متغیرها و توابع و.. در درون تمامی فایل‌های go مربوط به اون پکیج در صورتی که  exported باشند دسترسی خواهی داشت.
نکته‌ی بعدی وجود go.mod هست، شما حتما باید در سطح دایرکتوری اصلی، اونجایی که میخوای اون فایل اصلی go را بزاری که پکیج main و func main را توش تعریف میکنی، و ممکنه یه سری فایل دیگه‌ی go هم بزاری که اونها هم لزوما پکیجشون main خواهد شد چون تو پوشه‌ی یکسان هستند و گفتم خیلی مرسوم نیست در مسیر اصلی چند تا فایل go باشه با این حال در هر صورتی باید از دستور go mod استفاده کنی، یعنی حتما باید 
go mod init Ee_esm 
را به کار ببری، نکته‌ای که هست این اسمی که اینجا مینویسی همون اسمی هست که بعدا که میخوای دایرکتوریهای داخلی این مسیر و کل پروژه ات را باهاش صدا کنی هنگام import کردن، لذا میشه گفت نماد پوشه‌ی فعلی خواهد بود و بهتر هست اسم همون دایرکتوری اصلی پروزه است که مبدا همه‌ی فایلهات هست باشه
یعنی فرض کن یه دایرکتوری hasan داخل همین دایرکتوری اصلی پروژه ات میزاری که یک یا چند فایل go داره، تو میخوای در main از این فایلها استفاده کنی، پس باید import کنی، چیزی که اهمیت داره تعریف go.mod به شکل بالا هست و دادن یک نام مشخص. فرض کنیم اگر این نام simple بود یعنی هنگام ساخت go mod init simple نوشتی، حالا تو وقتی میخوای اون مسیر hasan را import کنی به صورت زیر این کار شدنیه:
import "simple/hasan"
و در نهایت با hasan و سپس دات هم دسترسی داری به متغیرها و توابع تمامی فایلهای go داخل این مسیر با اسم مستعار هم میتونی کار خودتو راحتتر کنی مثلا:
import a "simple/hasan"
و بعد با a دسترسی بگیری، البته اینها به شرطی هست که اسم پکیج در اون دایرکتوری را هم همنام اسم دایرکتوری و  hasan تعریف کرده باشی، اما اگه اسم پکیج را برای تمامی فایلهای داخل اون مسیر مثلا reza تعریف کردی، وقتی میخوای import کنی، بدان که با اسم پکیج میتونی دسترسی بگیری نه اسمی که import میکنه و توصیه میشه که بهتره برای خوانایی نام مستعار به کار ببری، البته اینکه نام مستعارت چی باشه مهم نیست. چون اسم پکیج با اسم دایرکتوریت متفاوت هست. ولی خب بهتره اگه میخوای این کار و بکنی کلا اسم پکیج با اسم دایرکتوری یکی باشه و اگر هم نبود، حداقل بعدا که میخوای import کنی برای اینکه بعدا تو کدت که میخوای هی با اسم پکیج فراخوانی کنی درصورتی که موقع import اسمی به کار نبردی و صرفا مسیر دادی، بهتره alies بزاری و بهتره الیاسه باشه و البته اسم پکیج باشه، نه یه اسم جدید.
import reza "simple/hasan"
و در نهایت با reza و سپس دات هم دسترسی داری به متغیرها و توابع تمامی فایلهای go داخل این مسیر

نکته‌ی دیگه اگه دایرکتوری اصلی که همه‌ی این قصه ها را براش گفتیم خارج مسیرهای GOROOT , GOPATH هست، برای اینکه go بتونه نگاهش کنه و ارور اینکه اقا من نمیتونم import کنم و نمیشناسم مسیری که دادی را در کنار لزوم وجود go.mod ، باید مقدار متغیر محیطی GO111MODULE="on باشد تا کامپایلر به کمک go.mod که داخل مسیرت تعریف کردی، در هنگامی که میخوای اجرا کنی بتونه تکلیف خودشو بفهمه که این مسیر تو را هم در نظر بگیره. و اگر این متغیر off بود یا مقدار نداشت، برای اینکه اوکی بشه و خطا نگیری که اقا نمیشناسم مسیری که زدی را باید دستور زیر را اوکی کنی:
go env -w GO111MODULE=on
که زین پس اوکی خواهد شد و اگر دایرکتوری تو go.mod را داشته باشه، وقتی import کنی به راحتی میبینه کامپایلر و روال خواهد بود. در نهایت یک مثال:
یک پوشه‌ی test من میسازم.
golangprograms.com/how-to-use-function-from-another-file-golang.html


÷÷÷÷÷÷÷÷÷ نقطه‌ی شروع برنامه‌های golang ای یا entry point اشون، حتما باید داخل pacakge main و تابع main باشد. یعنی شروع برنامه از اولین خط تابع main داخل package main خواهد بود. 
این تابع mian هم آرگومان ورودی و خروجی ندارد.

÷÷÷÷÷÷÷÷÷ اگر پکیج main شما دارای چند تا فایل مختلف هست باید دقیقا موقع بیلد یا ران اسم تک تکشون را بدی بهش، برای بقیه ی پکیج ها که import میشند اینکار لازم نیست ولی برای پکیج main اگر چند تا فایل داشت، این کار را حتما انجام بده، ضمنا ترتیب اینکه چطوری پاس بدی اسم فایلها را هم مهمه، مثلا سر تابع init هاشون، اگه با ترتیبی متفاوت از ترتیب اسمهاشون که تو فایل هست بدی، تابع init هاشون را هم با همون ترتیبی که پاس دادی اوکی میکنه، 
و نکته‌ی بعدی اینکه اگه همه‌ی فایلهایی که مال پکیج هستند را خواستی در بیلدت سهیم باشند، یا در رانت، به جای اینکه تک تک اسمها را بدی میتونی از  دات استفاده کنی یعنی: . go run یا . go build و در این حالت ترتیبشون هم میشه همون ترتیب اسمهاشون در پوشه ی اصلی، و این یعنی اگه init هم داشته باشند به ترتیب اسامی مییره جلو، دقیقا مثل زمانی که یک پکیجی را import میکنی، و داخل فایلهاش init داره و به ترتیب اسم فایلها میره سراغ init هاشون.
فیلم جلسه ۶

÷÷÷÷÷÷÷÷÷ نوشتن یک برنامه گو
ساخت یک پوشه و ساخت یک برنامه به اسم main.go
پکیج: یک راه ساختارمند کردن کد هست. دسته بندی کردن کدها هست.
در هر پوشه‌ای که داریم، در تمامی فایل‌هایی که go. هستند فقط نام یک پکیج را میشه استفاده کرد. نمیشه نام پکیج بین اینها متفاوت باشه. خطای multiple package in a directory میگریم.

فعلا با go.mod هم کاری نداشته باشید، اما اگه خواستید در پوشه‌ای کد بزنید. و go.mod نداشت. دستور زیر را بزنید:
go mod init yeEsmi
ترجیحا اسمه ، اسم پوشه‌اتون باشه.
همچنین بعد از اجرای دستور فوق فایل go.mod در پوشه ساخته میشه.
حالا اگه من میخوام یک برنامه بنیوسم که اجرا بشه، باید یک پکیج main را داشته باشد و باید تابع main را هم داشته باشد.
توضیح مربوط به go mod و متغیر‌های محیطی که البته هم مفید بود هم ناقص در فیلم پنجشبنه ۲۷ بهمن از اول تا دقیقه ۲۸
دستور export برای ترمینال فعلی مقادیری که برای متغیرها ست میکنی را لحاظ میکنه
برای تغییر متغیرهای محیطی در گولنگ از 
go env -w ENV=...
استفاده کنید که ENV همون متغیر محیطی هست و مقداری که رو به روش میزاری مقداری که میخوای بگیره هست.
اگه به شکل گلوبالی خواستی تغییر بدی میتونی به متغیر های go هم مثل متغیر های دیگر در لینوکس نگاه کنی.
 
÷÷÷÷÷÷÷÷÷ توضیحی در مورد import کردن:
import (
	"fmt"
	"math/rand"
)
معادل
import "fmt"
import "math/rand"
این اسلش به خاطر همون ساختار تعریف این ماژول math هست، الان ما پوشه math را داریم، ولی داخل خود math یه پوشه‌ی rand داریم که داخل rand کدهای go قرار داره لذا وقتی import میخوای صرفا از همون چیزهایی که تو پوشه‌ی rand هست، استفاده کنی باید همون rand را بیاری، و نکته اینجاست که اگه خواستی هم از تعدادی از فایلهایی که تو math هست استفاده کنی هم از تعدادی از اونا که تو rand هست، باید جدا جدا جفتشون را بیاری یعنی هم math هم math/rand در واقع اینطوری برات بگم که این دو تا در عمل هیچ ربطی به هم ندارند، هر وقت خواستی کار کنی باید مثل دو تا ماژول جدا ببینی، فقط نکتش اینه که برای تمیز تر شدن rand را نیمدن جدا کنند یه دایرکتوری بسازن رفتن گذاشتن تو پوشه math و مسیرش این هست و گرنه با یک ماژول دیگه که میاری هیچ فرقی نداره.
import "fmt"
import "math"
import "math/rand"
func main(){
	fmt.Println(math.Abs(12))
	rand.Float32()
}

finish
-------------------------------------------------------------------------------
|^^^| Packages:
÷÷÷÷÷÷÷÷÷ بحث go sdk library
خود go یکسری کتابخونه داره که در قالب پکیج ها در اختیارشون داره مثل pacakge "fmt - داخل go land یک قسمت external library هست، که در قسمت Go sdk تمامی این کتابخونه های اون ورژنی از go که داریش در دسترس گذاشته و داخل هر کدوم هم یک فایل doc.go هست که توضیحات اون کتابخونه را نوشته به راحتی با import میتونی بیاریشون. که تو مسیری که  GOROOT هم نشون میده داخل بخش src میتونی ببینی این پکیج ها را  و همون go doc و غیره را...
مسیر GOROOT مسیری هست که هم کامپایلر golang هم سورس کدهای کتابخونه‌های استاندارد گو قرار میگیره، دقیقا کامپایلری که استفاده میکنی تو مسیر usr/local/bin/go هست. اما GOPATH اون مسیری هست که شما میخوای سورس کدهای پروژه‌های خودت را و پکیج‌های شخص ثالثی که خودت دانلود میکنی را قرارشون بدی.

÷÷÷÷÷÷÷÷÷ پکیج‌های hashing 
کلا برای دیدن توضیحات هش اول این جا را ببین:
https://golangprojectstructure.com/hash-functions-go-code/
برای نمونه اونایی که تو کتابخانه‌های استاندارد هستند:
Adler-32			"hash/adler32"
CRC-32				"hash/crc32"
CRC-64				"hash/crc64"
FNV					"hash/fnv"
MD5					"crypto/md5"
SHA-1				"crypto/sha1"
SHA-224 and SHA-256	"crypto/sha256"
SHA-384 and SHA-512	"crypto/sha512"
که خود این crypto پره از این هش‌های مختلف:
https://pkg.go.dev/crypto

کتابخونه‌های غیراستاندارد که باید دانلود کنیم هم هست: که اسمش bcrypt هست و لینکش در زیر هست
https://pkg.go.dev/golang.org/x/crypto/bcrypt
آموزشش هم در ادامه آوردم:
https://dev.to/nwby/how-to-hash-a-password-in-go-4jae

مثال: الان یک نمونش کد زیر هست که پسورد را در قالب اسلایسی از بایت میگیره، و بعد هش encode شده را که هدف از encode هم ذخیره‌ی داده در قالب کارکترهای قابل نمایش هست، برمیگردونه: ینی هم پکیج crypto/sha512 برای هش کردن استفاده شده که خروجی هش hash.Sum(nil) هست که اسلایسی از بایت هست. حالا اگه اینا شما بدین به string احتمالا خیلی از کارکترها قابل خوندن نباشند برای اینکه این مشکل حل بشه ما اینا encode اش کردیم به کمک پکیج "encoding/base64" که یک اسلایسی از بایت میگیره و خروجی به ما یک رشته‌ی encode شده میده.
پس از کد درباره پکیجهای encoding هم نوشتم.
func hashPassword(password []byte ) string{
	hash := sha512.New()
	hash.Write(password)
	encodedHash := base64.StdEncoding.EncodeToString(hash.Sum(nil))
	return encodedHash
}

÷÷÷÷÷÷÷÷÷ پکیج encoding
روش‌های مختلف encoding در go در این لینک امده:
https://pkg.go.dev/encoding
ascii85 ==  implements the ascii85 data encoding as used in the btoa tool and Adobe's PostScript and PDF document formats.
asn1 ==  implements parsing of DER-encoded ASN.1 data structures, as defined in ITU-T Rec X.690.
base32 == implements base32 encoding as specified by RFC 4648.
base64 == implements base64 encoding as specified by RFC 4648.
binary == implements simple translation between numbers and byte sequences and encoding and decoding of varints.
csv == reads and writes comma-separated values (CSV) files.
gob == manages streams of gobs - binary values exchanged between an Encoder (transmitter) and a Decoder (receiver).
hex == implements hexadecimal encoding and decoding.
json == implements encoding and decoding of JSON as defined in RFC 7159.
pem == implements the PEM data encoding, which originated in Privacy Enhanced Mail.
xml == implements a simple XML 1.0 parser that understands XML name spaces.

یک نمونه مثال عملی برای encoding از نوع base64:
https://pkg.go.dev/encoding/base64#example-package

÷÷÷÷÷÷÷÷÷ پکیج flag 
پکیج خیلی خوب برای نوشتن برنامه‌های cli در go این flag هست.
برنامه‌هایی cli ای چون میخوان ارگومان ورودی احتمالا بگیرن، دیگه go run نوشتن خیلی جالب نیست(چرت گفتم اینو اما بقیشو بخون)، باید بیلد کنی تا کامپایل بشن و فایل باینری را بهت بدن، از روی فایل باینری برنامه را اجرا کنی و اگر خواستی ارگومان و یا فلگی هم بهش پاس بدی ، تو گویی داری یه برنامه تحت cli را اجرا میکنی، راحت بهش پاس بدی. مثل مثلا کامند ls که یک برنامه است که فلگهای مختلفی میشه بهش داد.
توجه کن که میتونی از go run هم استفاده کنی، که مثلا به شکل زیر هست:
go run cliAppOnline.go -name=armin -age=22
الان دو تا ارگومان هم پاس دادم، و نیمدم اول بیلد کنم بعد فایل اجرایی را بهش اینا را پاس بدم، در جا با همون run هم میشه اوکی کرد

با پکیج builtin flag در go میشه مدیریت ارگومان‌هایی که پاس داده میشه به فایل اجرایی و به عهده گرفت، اگر همچین چیزی نبود، خودت باید از صفر همه چیش را کدش را میزدی، اما با وجود این flag میتونی کار و جمع کنی، کافیه اون پارامتر‌هایی که میخوای فلگهات باشن را بیای بدی مثلا به flag.String، با این تابع میتونی فلگ را تعیین کنی، مقدار دیفالت بدی، و دیسکریپشن برای help ای که خودکار خود این پکیج برات میسازه از فلگ‌ها را اوکی کنی.
new1 := flag.String("name", "empty", "just say hello")
الان ورودی یک flag name هم میگیره، که یا به صورت =name- یا =name-- خواهد بود، مقدار پیش فرضی را اگه کاربر نداد بهش میدی که همین ارگومان دوم هست، و درنهایت یه دیسکریپشن هممیزاری که برای داخل help یادداشت کنه. خروجی هم یک پوینتر از جنس string هست. که برای دسترسی به مقدار این flag چه کاربر بزنه چه نزنه باید * اشو بزاری یعنی new1* میتونه مقداری که یارو انتساب داده را ببینی. در ضمن یک flag.Parse هم هست که اینه که میره فلگهایی که به فایل اجرایی پاس داده میشه پارس میکنه، اگه اینا بعد این انتساب ها نزاشتی، پارس نمیکنه. یه flag.Int هم هست که همین صوبتاس فقط برای فلگهای هست که مقدارشون int هست و قاعدتا خروجیش هم پوینتری به int خواهد بود.
به شکل خودکار h- یا help-- هم دیسکرپیشن را از روی فلگ‌هایی که خواستی بسازی میسازه.

تابع flag.Args() هم اسلایسی هست که بقیه‌ی ارگومان‌هایی که در کامندلاین پاس دادیم ولی جز flag ها نبودند را میاد لیست میکنه
توجه کن: اگر به محضی که یک ارگومانی پاس بدی که جز فلگها نباشه دیگه مابقی هم تو جوب خواهد بود. چه فلگ تعیین کردی باشی براشون چه نکردی، و همه را از دم جز اضافه میبنیه و میره تو flag.Args

÷÷÷÷÷÷÷÷÷ پکیج os
خب ورودی‌هایی که تو به عنوان آرگومان به برنامه‌ی باینری پاس میدی، در اسلایس os.Args از کتابخونه‌ی Args ریخته میشه که os.Args[0] همیشه میشه همون اسم فایل اجرایی مثلا app.out/. نکته‌ای که هست چییز که باعث میشه این فلگ‌های مختلف را بینشون تمایز قائل بشه، در واقع اسپیس هست.

ورودی‌های کامندلاین زمانی که فایل باینری اجرا میشه، توسط os.Args به عنوان اسلایسی از رشته‌ها در دسترس هستش، که خونه‌ی صفرمش همیشه اسم همون فایل اجرایی هست و خونه‌هایی بعدی اگر چیزی پاس داده باشی ( به شرط جدا کردن با spcace) میشن خونه‌های بعدی

÷÷÷÷÷÷÷÷÷ پکیج bufio
scanner := bufio.NewScanner(os.Stdin)
scanner.Scan() 
خط به خط ورودی کاربر را اسکن میکنیم ، با این تابع خط کاربر اسکن میشه
scanner.Text()
 با این متود ورودی‌ای که کاربر مینویسد و  ما اسکنش کردیم را میتونیم در قالب رشته بگیریم.
فایل را که open کردی میتونیم به جای os.Stdin بهش پاس بدیم.

finish
-------------------------------------------------------------------------------
|^^^| types
÷÷÷÷÷÷÷÷÷ خب basic type ها که مشخص هستند همون string , int اینا هستند. یه سری تایپ ترکیبی هم داریم، که خودت میسازیشون. توجه شود که struct ها که ما تعریف میکنیم یک سری تایپ هستند مثل int , string که میتونیم ازشون variable , نمونه بسازیم. در واقع یک نمونه custom type .
÷÷÷÷÷÷÷÷÷ این error از جنس interface هست. و interface از جنس costom type هست. درصورتی که مثلا string از جنس  basic type هست. 

÷÷÷÷÷÷÷÷÷ بحث تبدیل تایپ‌های مهم به همدیگه:
برای تبدیل int به string میشه از  fmt.Sprint استفاده کرد، کافیه var یا کانست را با هر تایپی بدی بهش و بهت string اون را برگردونه، از اون طرف strconv.Itoa هم هست که صرفا برای تبدیل تایپ int به string کاربرد داره.
string_type := fmt.Sprint(every_type)
string_type := strconv.Itoa(int_type)
توجه بشه که تابع string() به درد تبدیل نمیخوره، چون برخلاف انتظارمون که مثلا 90 را بکنه "90" نیست و میاد میکنه Z در واقع میاد اسکی معادل عددی که گذاشتی را برمیگردونه الان کد اسکی معادل 90 در واقع Z هست و نمیاد "90" بده به ما.
با این حال این تابع string به درد اینم میخوره که مثلا rune یا int8 بهش بدی تا بتونی مثلا از کلیه‌ی توابع string برای اون ورودی از جنس rune یا int8 استفاده کنی اوکیه با این حال در چنین حالتهایی میتونی به همون کتابخونه unicode هم فک کنی به جای اینکه بیای و به کتابخونه های string رجوع کنی.

همچنین برای تبدیل string به int روش زیر استفاده میشه که در این حالت هم در صورتی که شدنی باشه و اروری در کار نباشه به کمک روش زیر هست در واقع اگر درست باشه مقدار err همان nil میشه و اگه اشتباه باشه، باگ بلند میشه:
int_type, err := strconv.Atoi(string_type)

شما int بزرگتر را میتونی به کوچیکتر کانورت کنی اما ممکنه اور فلو بشه و مقدارش تغییر کنه الان مثلا int8 بین -۱۲۷ تا ۱۲۸ هستش و اگه مثلا ۱۰۰۰ را بخوای به اون تبدیل کنی مشکل میشه:
var i16 int16 = 1000
var i8 int8
i8 = int8(i16) //-24

÷÷÷÷÷÷÷÷÷ بحث rune , byte
چرا int8 را گفتن byte و int32 را گفتن rune ؟ بیشتر برای ریدبلیتی یا خوانایی ، به هر حال int32 عملا نشان دهنده‌ی کارکتر هست و int8 هم نشان دهنده‌ی بایت، ولی وقتی تو صرفا با دیدن int8 ,int32 به سرعت نمیتونی اینا تو ذهنت تداعی کنی و برای خوانایی بهتر اومدن الیاس گذاشتن. type alias را سرچ کنی گفتم.
خب مسلمه خوانایی byte خیلی بیشتر هست تا uint8 به ویژه وقتی مثلا در سطح شبکه پکتها به شکل بایت خوانده میشن حالا شما بخوای بزاری uint8 هم مشکلی نیست ولی مسلمه byte خواناتر هست و بهتر اون پکتی که داره بررسی میشه را نشون میده.

÷÷÷÷÷÷÷÷÷ تفاوت rune , byte
دقت بشه که مثلا 'h' در عمل تایپ rune هست و نه تایپ byte . البته قابل تبدیل هستند با type conversion اما شما وقتی با '' تعریف کنی در عمل rune میشه دلیلش هم این هست که rune در واقع int32 هست و فضای خیلی بیشتری را پوشش میده و فقط به کارکتر های اسکی خلاصه نمیشه و میتونه زبانهای مختلف مثل چینی و فارسی و پشتیبانی کنه و فقط به حروف زبان انگلیسی یه سری کارکتر چاپی و اعداد که در اسکی هستند و حدود ۱۲۸ تا هستند خلاصه نشه. اگه میخواست '' را به byte یا همون uint8 ببینه خیلی محدود میشد و فقط باید به همون ۲۵۶ تا نهایتا که ۱۲۸ تا اسکی را پوشش بده اکتفا میکرد.
ضمنا تایپ rune یا کارکتر قابل اضافه کردن و پیمایش می‌باشد:
for ch := 'a'; ch <= 'z'; ch++ {
	fmt.Printf("%c", ch)

÷÷÷÷÷÷÷÷÷ دسترسی با ایندکس به عناصر رشته
وقتی با ایندکس به عناصر رشته دسترسی میگیری، به تو تایپ byte یا uint8 برمیگردونه که عملا کدهای اسکی را نهایتا ساپورت میکنه، اگه کارکترشو خواستی باید string اشو بگیری
s := a2min
s[0] ---> 97
string(s[0]) --> a
s[1] --> 50  همان کد اسکی مربوط به عدد دو
int(s[1] - '0') --> 2 اگر خود عدد راخواستی باید اینطوری بری

الان در مثال زیر تایپ n در واقع rune یا int32 هست. فقط و فقط یک کارکتر میتونه باشه.
n := 'v'
و در مثال زیر تایپ n در واقع string هست.
n := "v"
توابعی که برای تایپه rune به کار میرند از کتابخونه unicode استفاده میکنند و توابعی که برای string به کار میرند از کتابخونه strings الان در مثال فوق در صورتی که اولی باشه و rune باشه خط اول فقط درست هست و اگر string باشه فقط خط دوم درست هست. 
n = unicode.ToUpper(n)
n = strings.ToUpper(n)
حالا رشته ها وقتی با اندیس به یک char دسترسی میگیری، جنس اون از جنس int8 هست و برای اینکه بخوای با rune کار کنی باید حتما کاست rune را انجام بدی براشون یعنی مثلا n[0] خروجیش یک کارکتر از تایپ int8 هست، و اگه خواستی از کتابخونه unicode استفاده کنی باید از  rune() استفاده کنی برای کاست کردن.
و نکته‌ی دیگه اینکه وقتی حلقه روی رشته میزنی، اون مقدار دوم که value هست، و عملا هر بار به یکی از کارکترهای رشته داره اشاره میکنه، و عملا داره رشته را پیمایش میکنه، هر کارکتر را از تایپ rune میبینه، گویی آنکه قبل اینکه تو بخوای کار کنی خودش کاست به rune را انجام داده. 
در واقع اگه خودت جدا بخوای به عناصر رشته دسترسی بگیری، تایپی که بهت برمیگردونه int8 هست ولی وقتی با for یک رشته را پیمایش میکنی، تایپی که برای هر کارکتر برمیگردونه int32 یا رون هست و بدون کاست کردن میتونی از توابع unicode استفاده کنی. 
در مثال زیر دقیقا این تفاوت را میبینی و مثلا اگه بخوای تابع unicode.ToUpper را روی n[i] صدا بزنی بهت ارور میده و میگه تایپ n[i] در واقع int8 هست و تابع بالا ورودی int32 میگیره و اگه واقعا بخوای این کار و کنی باید عملا زیری را بری:
unicode.ToUpper(rune(n[i])
در صورتی که تو پیمایش حلقه میبینی که l دیگه نیاز به اون cast نداشت و جنس خودش اتوماتیک rune بود.
و در نهایت در هر دو هم اگه بخوای از توابع string استفاده کنی باید کاست string را بریِ، همه ی اینها را در زیر آوردم:
package main
import (
	"fmt"
	"strings"
	"unicode"
)
func main() {
	n := "val"
	for i, l := range n {
		fmt.Printf("type:%T value:%v,,, type:%T value:%v,,, type:%T value:%v,,, type:%T value:%v,,, type:%T value:%v,,, type:%T value:%v,,,\n",
			n[i], n[i], l, l, unicode.ToUpper(l), unicode.ToUpper(l), unicode.ToUpper(rune(n[i])), unicode.ToUpper(rune(n[i])),
			strings.ToUpper(string(l)), strings.ToUpper(string(l)), strings.ToUpper(string(n[i])), strings.ToUpper(string(n[i])))
		break
	}
}



÷÷÷÷÷÷÷÷÷ برای تبدیل یک رشته به اسلایسی از بایت‌ها به راحتی میتونی رشته‌ی مربوطه را به byte[] پاس بدی که در نهایت، رشته را در قالب اسلایسی از بایت‌ها بهت برمیگردونه :
fmt.Println([]byte(userCommand))


÷÷÷÷÷÷÷÷÷ تفاوت تایپ الیاس و تعریف تایپ جدید:
دقت کن الان type definition به صورت زیر هست:
type ahmad int 
var a ahmad
var i int
a = i //error
این خطا میده و باید صراحتا از یک نوع تایپ باشند مگه اینکه از type conversion استفاده کنی:
a = ahmad(i)
این الان اوکیه

اما حالا type alies که کاربردش در خوانایی هست را ببین:
type ahmad = int
var a ahmad
var i int
a = i 
این ولی اوکیه فرق این دوتا اینه که اولی داره یه تایپ جدید تعریف میکنه ولی دومی داره صرفا alias میکنه تایپ int و یعنی شما یه جا حال نکردی با اسم یه تایپی میتونی با type , = یه اسم جدید بهش بدی. ولی اگه خواستی تایپ جدیدی تعریف کنی باید بدون مساوری به کار ببری، برای همین هم هست که انتساب را در دومی اجازه داد چون عملا هر دو یک تایپ هستند و صرفا الیاسه برای int اما در اولی داری یه تایپ جدید تعریف میکنی، که بر پایه‌ی int هست ولی خب چون یه تایپ جدید هست، اجازه‌ی انتساب دو تایپ مختلف را نمیده مگه به کمک type conversion.
یه نمونه از type alies مثال زیر هست:
type byte = uint8


÷÷÷÷÷÷÷÷÷ نکاتی در مورد type alies شما میتونی به تایپ مثل یک حالت alies نگاه کنی الان مثال زیر و ببین 
type Histogram map[byte]int
عملا یه تایپ جدید به اسم Histogram تعریف کردیم که در واقع یک مپی هست بین byte , int 
تو حتی میتونی تایپ‌هایی که موجود هستند را هم بیای یه تایپ جدید کنی مثل زیر :
type DNA string
حالا مزیت این یکی چیه؟ ببین ممکنه تو دلت بخواد برای تایپ استرینگ یک متود جدید تعریف کنی، و متودهای خودت را براش داشته باشی، برای اینکه بتونی متود بنویسی و در واقع فانکشن‌هایی بنویسی که رسیورشون یک string باشه، باید بیای یه تایپ جدید تعریف کنی و اون تایپ و اوکی کنی:
func (d DNA) Counts() (Histogram, error) {}
الان تو این مثال ما تایپ DNA را ترعیف کردیم و یک متود جدید هم براش ساختیم به اسم کانت، حالا هر نمونه‌ای که از این تایپ DNA ایجاد کنیم، دارای متود Counts خواهد بود. مثلا:
var tmp DNA = "GATGACA"
tmp.Counts()
داخلی ویدئو‌ها هم در این مورد توضیح داده شده.

finish
-------------------------------------------------------------------------------
|^^^| variable
÷÷÷÷÷÷÷÷÷ چهار شکل انتساب و تعریف متغیر
var name string
name = "ali"
-------------
var name string = "ali"  (initial value)
-------------
var name = "ali" 
-------------
name := "ali"  (short declaration)
--------------
اگر از تایپ‌های مرسوم نبود:
var i int8 = 0
-------------
i =: int8(0)
---------------

وقتی =: میزاریم کامپایلر متوجه میشه که ما داریم یک متغیر جدید تعریف میکنیم.
In Go, := is for declaration + assignment, whereas = is for assignment only
k := 3 معادله var k int = 3

÷÷÷÷÷÷÷÷÷ مقدار zero value برای pointer در واقع nil هست یعنی اگه یک پوینتر تعریف کردی که چیزی بهش فعلا منتسب نکردی، به صورت دیفالت مقدارش nil هست. 

÷÷÷÷÷÷÷÷÷ کاربرد new :
فیلم جلسه ۶ بخش new
از new برای رزرو کردن فضا استفاده میشه و هر تایبپی که بهش بدی، خروجی به تو یک پوینتری به اون تایپ را میده. که در واقع میاد یک فضایی از حافظه را رزرو میکنه به اندازه‌ی تایپی که تو خواستی و بعد یک پوینتر به اون فضا برمیگردونه.
t = new(int) //now t -> *int هست
*t = 4
حالا یکی از این تایپ‌ها خب استراکت هم میتونه باشه یه نگاه دقیقتری به استراکتش بندازیم:

÷÷÷÷÷÷÷÷÷ تفاوت new کردن با پوینتر گرفتن
در مثال زیر دو متغیر مختلف داریم که هر دو پوینتر به int تعریف شدند. نکته‌ای که وجود دارد این هست که هر دو عملا از فضای هیپ احتمالا استفاده خواهند کرد.
با این تفاوت که هر بار از new استفاده میکنید در کنار فضایی که تخصیص میده و ادرسشو برمیگردونه، مقدار داخل اون فضا را هم با zero value اون تایپی که فضا را براش اختصاص داده پر میکنه، و همین باعث میشه اگه حواست نبود و خواستی به محتوا دسترسی بگیری، پنیک نخوری، چون مقدار خواهد داشت و مقدارش zero value می‌باشد، اما اون خطی که صرفا پوینتر تعریف کردی، در این حالت صرفا مشخص شده که این متغیر قرار هست اشاره‌گری به یک int باشد، اما در عمل هیچ فضایی هنوز رزور نکرده است، در واقع میتوان گفت صرفا نقشش این هست که نوع متغیر تعریف شود که کامپایلر ارور نده و گرنه فضایی برای تو فعلا رزرو نمیکنه.
var a *int
b := new(int)


÷÷÷÷÷÷÷÷÷ پوینتر به استراکت با new
فیلم جلسه ۶ بخش new
نحوه‌ی تعریف پوینتری به struct، سه روش را در کد زیر گفتم ، روش اول با new هست که یک فضایی را رزرو میکنه و u میشه پوینتری به استراکت. در این حالت فضا رزرو میشه، پوینتر بهش اوکی میشه، ولی مقادیر ایتم‌های استراکت همگی  zero value خواهند بود.

روش دوم : در این حال نیز uu یک پوینتر به استراکتی از جنس User خواهد شد، {} باعث میشود که مقدار المانهای این استراکت zero value شوند. همچنین در این روش شما خودتون میتونید داخل {} همه یا هر کدوم از المان های استراکت را initail value مورد نظر خودتون بدهید، و اون المانهایی که مقدار نمیدید همون zero value میمونند. مثلا 
uu := &User{ID = 1,}

روش اول و دوم: هر دو از روش‌های خوب هستند اما تفاوت بهینه دارند (حس میکنم یکی از هیپ میگیره یکی از استک ولی مطمئن نیستم)

روش سوم آشغاله، تو میای یه پوینتر از جنس استراکت تعریف میکنی ولی فضایی برات رزور نمیکنه، در واقع پوینتر تعریف میشه ولی nil هست در واقع به جایی اشاره نمیکنه، در این حالت مسلما اصن حرفی از المان‌های استراکت مطرح نیست، لذا اگه به اشتباه بخوای به المانهای استراکت دسترسی بگیری پنیک میخوری، و اصلا روش خوبی نیست.
هر سه در ادامه اومده
type User struct {
	ID   uint
	Name string
}

func main() {

	i := new(int)
	fmt.Printf("type of i: %T\n", i)

	u := new(User)
	// u := inital value != nil
	// the user is zero value u.ID = 0, u.Name = ""

	fmt.Printf("type of u: %T\n", u)

	uu := &User{}
	// uu := inital value != nil
	// the user is zero value uu.ID = 0, uu.Name = ""
	fmt.Printf("type of uu: %T\n", uu)

	var uuu *User
	// pointer := zero value = nil
	// nil.ID
	// nil.Print()

	fmt.Printf("type of uuu: %T\n", uuu)

	fmt.Println("u.ID", u.ID)
	fmt.Println("uu.ID", uu.ID)
	fmt.Println("uuu.ID", uuu.ID)
}

÷÷÷÷÷÷÷÷÷ بحث ‌exported , unexported
بحث expected , unexpected که به کمک حروف اول بزرگ اوکی میشد در استراکت ها هم برقرار هست، اگر پراپرتی با حرف کوچک شروع شود، خارج از پکیج قابل دسترسی نخواهد بود
متغیر و توابع private که مخصوص همون پکیج هست و داخلی و درون پکیجی هست، و تو پکیج های دیگه استفاده نمیشن.
از اونطرف توابع و متغیرهای عمومی هم داره این پکیج که در بقیه‌ی پکیج‌ها هم میشه مورد استفاده قرار بگیرند، به اینها میگیم public ها
در golang برای مشخص کردن این که پابلیک هست یا پرایوت میگه اگه میخوایم تابع یا متغیرت، پابلیک باشه، بیا از حرف بزرگ ابتدای اسمش استفاده کن و بهش بگو exported شده ، اگر هم میخوای private باشه، بیا از حرف کوچیک اولش اسفتاده کن که میشه unexported اگر exported باشه، میتونی در پکیج‌های دیگه هم صداش بزنی ولی اگه  unexported باشه فقط داخل همون پکیج امکان صدا زدن متغیر یا تابع را خواهی داشت و از پکیج های دیگه قابل دسترس نخواهد بود.

÷÷÷÷÷÷÷÷÷ نکاتی در مورد const
مقدار constant هیچگاه در طول برنامه عوض نخواهد شد و همین مزیتش نسبت به var هست.
jens	esm	type 	=	meghdar
const	Pi	float64 =	3.14
var		i	int		=	7	
اگر مقدار دهی کردی میتونی تایپ را نزاری
jens	esm	=	meghdar
const	Pi	=	3.14
var		i	=	7
در ساختار بالا  فقط برای var میتونی ساختار زیر را بنویسی،  ولی برای const این ساختار را نمیتونی استفاده کنی:
i := 7

÷÷÷÷÷÷÷÷÷ اصطلاح Type inference: یعنی شما یه متغیر مثل i تعریف میکنی و حالا میای یه متغیر دیگه مینویسی و j = i میکنی، این j را اگه حتی تایپش را هم مشخص نکنی چون داری ظرف i را داخلش میریزی دیگه اوکیه کار.

finish
-------------------------------------------------------------------------------
|^^^| pointer
÷÷÷÷÷÷÷÷÷ ارسال مقدار به تابع در go به صورت ارسال مقدار می‌باشد. اگر خواستی رفرنس بفرستی باید گیرنده را از جنس پوینتر در ارگومان تعریف تابع تعریفش کنی، و هنگام فراخوانی هم آدرس پاس بدی. که البته این کار خیلی بده و باعث ناخوانیی کد می‌شود.
a := 42
print(&a)
func print(p *int){
fmt.Println(*p)}
÷÷÷÷÷÷÷÷÷ پس فرستادن با مقدار خیلی خیلی بهتر از ارسال با رفرنس هست، اینا خوب یادت باشه.
ولی خب در جاهایی مثل اسلایس و اینا دیگه مجبوریم، که خودشون را پاس بدیم. و اگه نخوایم اینکار و بکنیم باید یه کپی از کلش بگیریم که نمیصرفه، لذا برای اسلایس و اینا همون رفرنس ارسال میشه. و عملا خود اسلایس اصلی میتونه اماج تغییرات تابع قرار بگییره
در واقع هر زمان تابع شما یک اسلایس مثلا میگیره، تابعی که داره این اسلایس را میگیره میتونه مقادیر اسلایس را تغییر بده و این تغییرات روی اسلایس اصلی هم اعمال میشه چون در عمل اسلایس به صورت رفرنس یا پوینتر پاس داده میشه 
واقعا جایی که لازم ندارید استفاده نکنید.

همچنین وقتی مثلا users که یک اسلایس هست را به صورت زیر میفرستیش برای usersTwo تو در عمل اومدی گفتی usersTwo هم بیاد به همونجایی که users اشاره میکنه اشاره کنه، نیومدی مقادیرشو کپی کنی
usersTwo := users
برای اینکه بتونی واقعا کپی ایجاد کنی و نه این که جفت به یک جا اشاره کنند. و یعنی واقعا دومی صرفا مقادیر اولی را بگیره و هر گنده کاری روشون کرد به عهده خودش باشه و کاری به اولی نداشته باشه باید به شکل زیر بری:
copy(usersTwo, users)
ففقط توجه کن که باید usersTwo را تعریفش کنی با همون مقادیر و همون طول بعد از کپی استفاده کنی یعنی اول باید خط زیر اجرا بشه بعد تابع کپی را صدا بزن:
usersTwo := make([]int, len(users), cap(users))
پس نتیجه اخلاقی: خواسی از یک اسلایس کپی بگیری یا مپ یا هر چیز دیگه، همینطور  گتره‌ای انتساب نده، باید از تابع کپی استفاده کنی تا بتونی مقادیرش و بگیری و کارهایی که لازم داری را انجام بدی روش.

÷÷÷÷÷÷÷÷÷ انتهای ویدئوی method , pionter خوبه
÷÷÷÷÷÷÷÷÷ اما pointer از نوع reciver : زمانی که داری یک متود تعریف میکنی و reciver را براش میزاری میتونی بزاری مثلا s student میتونی بزاری s *student که ولی برای فراخوانی هر دو  s.Name خواهند بود.
حالا سوالی که هست اینه، فرقشون چیه ؟
در اینجا هم بحث همون call by value را داریم، شما وقتی * نمیزاری عملا وقتی مثلا میگی s.GetName این میاد و مقدارهایی که داخل s هست را یه جایی دیگه از حافظه کپی میکنه و بعد روی اونها فراخوانی را انجام میده. اما وقتی * میزاری این میاد خود s را در واقع ادرسش و پاس میده و لذا هر تغییری که بدی روش اعمال خواهد شد.
لذا در متودها اگر میخوای چیزی را عوض کنی باید اصولا از نوع پوینتر رسیور بزاری. یعنی   s *studnet


finish
-------------------------------------------------------------------------------
|^^^| errors
÷÷÷÷÷÷÷÷÷ اصطلاح error prone یعنی باگ خیز بودن، یعنی کد به گونه‌ای نوشته شده که احتمال خطا درش وجود داره.

÷÷÷÷÷÷÷÷÷ یک اررور رایج در زمان اجرا index out of range هست

÷÷÷÷÷÷÷÷÷ بحث panic handling 
می‌توان ارور panic را هندلش کرد و مانع از بسته شدن برنامه به شکل غیر منتظره شد.
کافیست تابع زیر قبل از خطی که panic قرار است رخ دهد نوشته شود:
defer func() {
	if err := recover(); err != nil {
		log.Println("panic occurred:", err)
	}
}()
در لینک زیر هم آمده:
https://www.digitalocean.com/community/tutorials/handling-panics-in-go#detecting-panics-with-recover

÷÷÷÷÷÷÷÷÷ این nil همون null هست، اگه خطایی نداریم، nil برمیگردونیم در غیر این صورت از یکی از errors.New یا fmt.Errorf برای برگردوندن خطا استفاده میکنیم.

÷÷÷÷÷÷÷÷÷ هر زمانی خواستی اکسپشن برگردونی در go کافیه از panic() استفاده کنی که ورودی هر چیزی را میگیره و بعد از خودش برنامه را میپره با خطا بیرون و در واقع اکسپشن برمیگرده.
اینجا هم روشهایی برای مدیریت panic در همون کد هست که اکسپشن برنگرده ولی try except نیست.
هر جا که ()panic را بزاریم، کد خطا میده و کلا کدمون دیگه کار نمیکنه و اکسپشن میزنه

÷÷÷÷÷÷÷÷÷ شکل خوب مدیریت err
اینجاهایی که اصولا تابع‌هایی را صدا میزنی که افزون بر خروجیشون error هم برمیگردونند، و لازم داری بررسی کنی که خطایی بوده یا نه، راه خوبش این هست که فراخوانی تابع و درنتیجه مقدار متغیرهای بازگشتی را داخل اسکوپ if تعریف کنی و بعد همون داخل if بیای و error را بررسی کنی : مثلا در مثال زیر اگه در نهایت خطایی رخ نده خروجی در filehandler که متغیری هست که خارج اسکوپ if هست ذخیره میشه و اگر خطایی رخ بده که return میشه، اینطوری اون err که تعریف شد فقط مختص همین اسکوپ هست و در ادامه هم باز میتونه چندین بار دیگه از همین ساختار برای توابع دیگه استفاده کنی چون err ها همه مختص همان اسکوپ خودشون هستند.
var filehandler *os.file
if f, err := os.open(); err != nil{
	fmt.Printf("errrorr")
	return
} else {
	filehandler = f
}
÷÷÷÷÷÷÷÷÷ لینک مفید برای مدیریت خطا
https://go.dev/doc/tutorial/handle-errors

÷÷÷÷÷÷÷÷÷ روش تمیز اوکی کردن خطا 
موقع نوشتن توابع خطا خیلی شیک و منطقی داخل تابع error برگردونه که مثلا به صورت زیر فرمی هست که تو تابع readDatatest نوشتم:
f, err := os.Open(datasetName)
if err != nil {
        return fmt.Errorf("error when open Dataset\n")}
و نحوه‌ی کنترل خطا داخل main که این تابع را صدا زده بودم به صورت زیر هست:
err := readDataset(datasetNameExist)
if err != nil{
	log.Fatalln(err)}
در واقع داخل تابع readDataset اگر خطایی رخ دهد من return میکنم لذا ادامه‌ی تابع اجرا نمیشه، زمانی که به main برگشتم، اونجا میام میبینم ایا از readDataset بدون خطا بیرون آمدم یا با خطا ، اگه خطایی بوده  همون خطا را میدم به fatal تا هم در خروجی چاپش کنه هم برنامه را با کد 1 ببنده.

÷÷÷÷÷÷÷÷÷ نکته‌ای در مورد خطای زمان اجرا و کامپایل در اسلایس و ارایه:
وقتی ارایه را  دسترسی به عنصری بدی که خارج از رنجش هست، خطای زمان کامپایل رخ میده چون همون زمان کامپایل میدونه سایز ارایه چی هست و خطا میده و نمیزاره که شما دسترسی به اون عنصر بگیری.
اما وقتی اسلایس را دسترسی به عنصر بخوای داشته باشی چه مقدار بدی چه مقدار بگیری، در صورتی که len اش به نحوی مشخص نشده و len اش صفر هست. در این صورت خطای زمان کامپایل نمیده ولی خطای panic میخوره در واقع خطای زمان اجرا براش رخ میده چون شروع میکنه به اجرا کردن بعد میبینه سایز slice صفر هست ولی تو خواستی مثلا به یک عنصرش دسترسی بگیری:
var sl []int
sl[0] = 10
در اسلایس مثل ارایه چون از قبل هیچ دیدی نسبت به سایز نداره، قبل اجرا خطای زمان کامپایل نمیخوره و میسپاره به زمان اجرا، ولی وقتی ران شد و در زمان اجرا میبینه len(sl) صفر هست، موقعی که دسترسی خواستی بگیری و ارور برمیگردونه باید از make استفاده کنی:
var sl := make([]int, 6)
sl[0] = 10
الان دیگه اوکیه چون len را 6 میبینه 
البته این نکته را هم بگم در مثال قبلی اگر از append استفاده کنی اوکی میشه:
var sl []int
sl = append(sl, 10)
دلیلشم خب واضحه که عملا sl داره  تغییر میکنه و در نتیجه len اش هم درست میشه که ارور نده و بعد از اون sl[0] هم در دسترس خواهد بود.
در همون مثال make هم اگه شما sl[6] که خارج از رنج هست را بخوای کال کنی خطای زمان اجرا میده ولی اگه قبلش append را به کار ببری اوکی میشه، در واقع تابع append کمک میکنه که سایز len اسلایس درست بشه و زیادش بتونی بکنی و در واقع مقدار len اسلایس به درستی تغییر کنه. برای کوچیک کردن هم که کافیه اسلایس کوچیکتر بریزی مثلا در مثالی که ۶ تا خونه داشت:
sl = sl[:4]
عملا سایز اسلایس را کوچیک کردیم و شد ۴ تا. و len هم اتوماتیک کم میشه البته کپاسیتی ثابت هست دیگه و کم نمیشه، مگه اینکه دوباره sl = make بزاری و دستی کپاسیتی را به عنوان ارگومان سوم بهش پاس بدی.

÷÷÷÷÷÷÷÷÷ 
finish
-------------------------------------------------------------------------------
|^^^| structure and data structure
÷÷÷÷÷÷÷÷÷ در ساختار swtich اگر تطابق با چند تا case اوکی بود، به اولین case ای که اوکی هست برسه، همونو اجرا میکنه و دیگه بیخیال بقیشون میشه.
ضمن اینکه میتونه csse ها کاملا به جای if , else تو در تو به کار بره ، بدون اینکه به متغیر خاصی نیاز داشته باشه، میتونه هم متغیر خاصی را بهش بدید مثل c اینا.
در ضمن اگر برای شرط case بین چند تا چیز میتونه اوکی باشه وقتی کاما بزاری بینشون اتوماتیک or اشون را در نظر میگیره،‌ یعنی مثلا case a, b, c اگه گذاشتی،‌میگه اگه مقدار متغیر مربوطه یا a شد یا b یا c من این case و اجرا میکنم.

÷÷÷÷÷÷÷÷÷ اصولا جاهایی که کیس‌ها زیاد هستند و overlap هم ندارند، باید از switch case اسفتاده بشه.

÷÷÷÷÷÷÷÷÷ بحث fallthrough در switch
نکته‌ی مهم آن است که وقتی از fallthrough استفاده شود، بدون چک شرط کیس بعدی، کیس بعدی را در جا اجرا میکنه. با همین دلیل هم خیلی کم استفاده میشه.


÷÷÷÷÷÷÷÷÷ تعریف استراکت:
type ESME struct {}

÷÷÷÷÷÷÷÷÷ نکته‌ای در مورد مقداردهی استراکت
اخرین فیلد یک استراکت که داری مقدار میدی، اگر استراکت را همونجا میبندیش در واقع پرانتزش را میزاری که دیگه کاما نمیخواد اما اگه میخوای پرانتز و بندازی خط بعد، واسه اخرین فیلد هم کاما را بزار ولو اینکه بعدش چیزی نیست.

÷÷÷÷÷÷÷÷÷ دو شکل مختلف پیمایش، اصن دومی خیلی استفاده نمیشه.
for i := range a {
		if b[i] != a[i] {
			hammingDistance++
		}
		
for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
		hammingDistance++
		}

÷÷÷÷÷÷÷÷÷ بحث goto , label
در زبان go از goto هم میتوان بهره برد، مثلا جایی که داخل یک if از  if دیگری استفاده کردید و میخواید حالتی مشابه با break داشته باشید باید مثلا از goto استفاده کرد. برای اینکار کافیست جایی که میخواید بهش بپرید را براش یک label بزارید، و بعد بنویسید goto EsmeLabel در این صورت از جایی که هستید میپرید به اونجا. یک نمونش مثال زیر هست که حلقه را با goto پیاده کردیم البته خب مسلمه for خواناتر هست این صرفا یک مثاله، و مشخصه که اسم لیبل مربوطه، start گذاشتیم: 
start:
fmt.Println(i)
i++
if i < 10{
	goto start
	}
fmt.Println("finish")

÷÷÷÷÷÷÷÷÷ نکته‌ای در مورد آرایه:
نکته‌ی مهم آرایه این هست که سایزش فیکس هست.
آرایه که کلا نمیشه سایزشو کم و زیاد کرد، اگه هم خواستی عنصری ازش حذف کنی صرفا میتونی مقدار اون index را تغییر بدی مثلا رشته خالی کنی ، اما اسلایس را میتونی عنصرش را کم و زیاد کنی، فقط برای حذف کردن عنصر از اسلایس تابع built-in وجود نداره، دو تا روش مختلف هست که عکسش را گذاشتم و در لینک زیر هم قرار داره:
https://yourbasic.org/golang/delete-element-slice/

÷÷÷÷÷÷÷÷÷ بحث تعریف و استفاده از map
این دو تا معادل هم دیگه هستند.
var myMap = map[string]int{}
myMap := make(map[string]int)

÷÷÷÷÷÷÷÷÷ پیمایش روی map ها
for k, v := range m { 
    fmt.Printf("key[%s] value[%s]\n", k, v)
}


÷÷÷÷÷÷÷÷÷ تعریف یک مپ در خارج از تابع و در فضا global به صورت:
var myMap = map[int]string{
    1: "one",
    2: "two",
    3: "three",
}

var users = map[string]int{}
users := map[string]int{}    



÷÷÷÷÷÷÷÷÷ کار با فایل:
https://kgrz.io/reading-files-in-go-an-overview.html
https://github.com/PacktPublishing/Mastering-Go/blob/master/ch08/save.go
https://www.golinuxcloud.com/golang-append-to-file/

https://www.golinuxcloud.com/golang-read-update-same-file/
https://zetcode.com/golang/bufio/
https://www.educative.io/answers/how-to-read-and-write-with-golang-bufio
https://golangdocs.com/golang-read-file-line-by-line
https://stackoverflow.com/questions/26152901/replace-a-line-in-text-file-golang
https://www.geeksforgeeks.org/how-to-read-and-write-the-files-in-golang/

finish
-------------------------------------------------------------------------------
|^^^| function

÷÷÷÷÷÷÷÷÷ فانکشن برای reusable کردن کد هست، به بخشی از کد قابلیت استفاده‌ی مجدد بدیم.

÷÷÷÷÷÷÷÷÷ وقتی میخوای برای توابعی که منتظر یک مقداری هستند return برگردونی و خطا ایجاد شده براشون اصولا از 1- استفاده میکنند به عنوان خطا.

÷÷÷÷÷÷÷÷÷ تابع init
نکته‌ی صفر: این تابع init برای اولین import می‌باشد. وقتی import شد و تابع init کال شد اگه بعد در پکیج های دیگه مجددا همچین پکیجی import شده بود دیگه init فراخوانی نخواهد شد. در واقع کلا گولنگ میاد از همون main شروع میکنه یه ساختار از کل این import ها در میاره که از main هم شروع میشه، از main به ترتیبی که import کردی میره سراغ پکیج ها و اگه init باشه اجراشون میکنه حالا اگه در همین ترتیب ها که جلو میره مثلا پکیج اخری که داری import میکنی در main از پکیج های قبلی که import کرده بودی و init اشون اجرا شد اومده باشه import کرده باشه، دیگه این init ها دوباره اجرا نیمشن چون init صرفا یکبار فراخوانی میشه ، در هنگام import شدن.
نکته‌ی اول ما در یک فایل می‌توانیم چندین تابع init داشته باشیم. و به ترتیب محل قرارگیریشون در کد اجرا میشوند.
نکته‌ی دوم توابع ‌init بدون فراخوانی قبل از هر تابع دیگری اجرا خواهند شد.
نکته‌ی سوم اگر یک پکیچی را import کردی، که دارای تابع init هست، همون موقع که import اش میکنی، تابع init اش هم فراخوانی میشه، یعنی مثلا شما داری در پکیج main یک چیزی import میکنی، اصن قبل اینکه تابع main اجرا بشه، همون موقع که داره پکیج های مختلف import میشه، اگه پکیج مربوطه، دارای تابع init باشه، این تابع در جا اجرا خواهد شد.
اگر یک فولدری داری، که فایلهای داخلش که خب میدونیم هم همگی هم باید از یک پکیج باشند، داخل همشون init در تعداد مختلف وجود داره، بسته به اسم فایلها و سورتی که شدند موقعی که مسیر مربوطه را import میکنی، یکی پس از دیگری init هاشون اجرا میشه مثلا اگر te1 te2 te3 داخل یک فولدر هستند و مثلا اسم پکیجشون hasan هست، اگر در main اومدی مسیر hasan را  import کردی، در همون لحظه به ترتیب اول تمامی init های داخل te1 سپس init های داخل te2 و... اجرا میشوند و دلیل این ترتیب هم اسمشون هست که te1 زودتر از te2 خواهد بود. و هر دو زودتر از te3
در فیلم جلسه ۶ اومده

÷÷÷÷÷÷÷÷÷ کاربردهای blank
سر نوشتن لوپ که بلدی، سر init هم که متوجه شدی
میمونه سر توابعی که مجبوری سیگنچرشون را حفظ کنی ولی مثلا اسفتاده نداری مثلا تابع زیر خب تو در این تابع تو صرفا از s استفاده کردی ولی مجبور بودی سیگنچر تابع را حفظ کنی، سیگنچری که میگه این تابع دو تا ورودی یک رشته و یک int میگیره و یک رشته برمیگردونه ولی در عمل از int عه استفاده نمیکنی، لذا نکته‌ای که اینجا مطرح میشه در جاهایی که مجبوری سیگنچر را حفظ کنی، ولی خب استفاده‌ای نداری، با این که کامپایلر ارور نمیده ولی وارنینگ میده برای اینکه اون وارنینگ هم نده از blank اینجا استفاده کن، که در واقع کار و برات جمع میکنه. و وارنینگ را از بین میره  -- فیلم جلسه ۶ اخرش
func test(s string, _ int) string{ 
	return fmt.Println(s)}

÷÷÷÷÷÷÷÷÷ ضمنا گاهی اواقت ممکنه بخواهی پکیچی را import کنی و ازش استفاده نکنی، و یا استفاده ات در حد همین init اون باشه، که یعنی تو چیزی را فراخوانی نمیکنی، بلکه همون موقع که impor میکنی خودش فراخوانی میشه و در کل در داخل کدت تو جایی از این چیزی که import کردی استفاده نمیکنی، لذا golang خب بهت گیر خواهد داد که اقا برش دار وقتی استفاده نمیکینی در صورتی که ممکنه تو واقعا از init اش که خودکار اجرا میشه داری بهره میبری، برای چنین مواقعی که کامپایلر گیر به کدت نده وقتی خواستی import کنی قبلش _ بزار یعنی:
import _ "UnEsmiKeToGoModGozashti/hasan"
البته این کار اصلا خوب نیست و بهش میگن side effect که خونایی کد را به شدت کم میکنه
در فیلم جلسه ۶ اومده

÷÷÷÷÷÷÷÷÷ اگر در تابع برای خروجی هم اسم گذاشتی مثلا 
func name() (s string)
و بعد تو تابع مقدار بدی به این s، در این صورت return خالی هم کافیه و هر جایی که این return را بزاری داخل تابع، کار و برات جمع میکنه و مقدار در همون لحظه‌ی s را هر چیزی که هست برات برمیگردونه. البته این کار خیلی خوانا نیست. چون  return خالی یوخده خوانا نیست. لذا بهتره واسه خروجی اسم نزارید و بعد در return دقیقا چیزی که میخواید را کنار return برگردونید فقط در نظر داشته باشید که تایپ چیزی که دارید کنار return میدید باید با چیزی که در تعریف تابع اومده یکسان باشه.
میشه برای خروجیها بیایم اسم بزاریم، در این حالت لازم نیست که دیگه اونها را مجزا تایپشون را تعریف کنیم اگر روش بالا را نمیرفتیم معادلش میشد ساختار پایینی که در این حالت دیگه ریترن خالی هم نمیتونی بزاری، چون ریترن خالی فقط برای خروجیهای اسم دار هست


÷÷÷÷÷÷÷÷÷ توابع چاپ مختلفی داریم فرض کنید دو متغیر زیر را داریم و دوست داریم متن زیرش را چاپ کنیم.
name := "armin"
age := 23
my name is Armin and age is 23
ابتدا fmt.Println
میتواند n ارگومان را از هر نوعی بگیرد.
آرگومان‌ها را در خروجی با space از هم جدا می‌کند.
انتهای چاپ خودش یک نیولاین یا n\ قرار می‌دهد.
fmt.Println("my name is", name, "and age is", age)

دوم fmt.Printf 
که به عنوان آرگومان اول string میگیره و اصطلاحا بهش میگن formatter و آرگومان‌ها بعدی باید به تعداد formmater هام، متغیر از همون تایپ مورد نیاز پاس بدم:
انتهای کار نیولاین نمیندازه، خواستی خودت باید بزاری
خوانایی بالاتری داره
fmt.Printf("my name is %s and age is %d\n", name, age)

سوم fmt.Sprintf مشابه با بالایی هست با این تفاوت که در خروجی چیزی را چاپ نمیکنه در کنسول بلکه یک string خروجی برمیگردونه

÷÷÷÷÷÷÷÷÷ خروج از تابع یا برنامه
وقتی تابع خروجی پاس نمیدهد اگر خواستی از return استفاده کنی، صرفا از یک return خالی استفاده کن. مثلا برای متوقف کردن main میتونی از return استفاده کنی، ولی توجه کن، return خالی یعنی برنامه موفق اجرا شد ، ولی اگه واقعا سر یه خطایی مجبور شدی از return استفاده کنی، این اشتباهه و بهتره بری سراغ روش بعدی:
تابع os.Exit را وقتی فراخوانی کنی، باعث بسته شدن برنامه میشه، با این نکته که یک status code میاد ورودی میگیره ، که به برنامه نویس و سیستم عامل کمک میکنه که نشون بده این برنامه‌ای که خاتمه پیدا کرده، آیا به شکل موفق خاتمه پیدا کرده یا مشکلی داشته و سر اروری که براش پیش اومده قطع شده، که status code مقدار صفر یعنی موفق، و غیر از صفر هم معنی های دیگه‌ای داره

حالا log.Fatalf را هم در نظر داشته باش، این تابع به غیر از اینکه برنامه را با os.Exit(1) که یعنی خطا داشته، میبنده، بلکه قبلش هم در کنسول هم پیغام مدنظرت را چاپ میکنه، چون خیلی اوقات ما لازم داریم قبل exit برنامه یه پیغام درست حسابی بنویسیم، در این مواقع به جای اینکه یک print بزاری و بعد os.Exit یکباره از این استفاده کن، ارگومان هاش هم دقیقا مثل Printf یا Sprintf هست، یعنی با d% و اینا میشه پیغام را متناسب با متغیرها تغییر داد. ضمنا تاریخ و ساعت را هم میندازه چون کلا نگاهش نگاه log هست.
پس به تفاوت‌ای return , Exit , Fatalf توجه کن و هر جا اون چیزی که حس میکنی خواناتر و بهتر است را بنویس

اگر خود کاربر خواست برنامه بسته بشه میشه از os.Exit(0) استفاده کرد.

÷÷÷÷÷÷÷÷÷ تفاوت بین scan , scanln
یک نکته درباره تفاوت Scanln , Scan  بگم اینه که ‌Scanln در عمل در ورودی وقتی که اینتر و بزنی هر چی زده باشی را به عنوان ورودی کاربر در نظر میگیره حتی اگه هیچی ننوشته باشی و اینتر بزنی، در واقع اینتر زدن تو پایان دادن به ورودی گرفتن هست. اما در Scan این قضیه متفاوت هست اونجا تو اگه چیزی ننوشته باشی یا فقط اسپیس و تب و اینا باشه هر چه قدرم اینتر بزنی، مهلت ورودی گرفتن و نمیبنده تا وقتی که بالاخره یه چیز درست درمون تایپ کن. 
بعد حالا نکته اینجاست که اگه در Scanln تو هیچی ننوشتی و همینطوری کشکی اینتر و زدی و کلا ورودی درست درمون ندادی، درسته که ورودی گرفتن و دیگه قطعش میکنه ولی خروجی ای که میده دو مقدار هست یک int میده که مقدارش صفر خواهد بود و یک ارور هم میده که unexpected newline هستش ولی اگه ورودی درست درمون بدی خروجی مقدار یک و ارور هم nil خواهد بود.

÷÷÷÷÷÷÷÷÷ نکته‌ای در مورد scanln:
این scanln از شما آدرستون (ادرس متغیرتون) را میخواد تا چیزی که قراره توش ذخیره بکنید را بره تو اون ادرس بنویسه و شما بتونید با متغیر به محتواش دسترسی پیدا کنید، مثه اینه ادرستو میدی یکی بره برات یه چیزی بزاره تو خونت، و وقتی برگشتی خودت میتونی به محتوای توی خونت دسترسی پیدا کنی.
خب این کار با var& دادن به scan اوکی میشه و محتوا هم در var قابل دسترسی هست.
اما اگه جنس var خودش از جنس پوینتر بود، چیزی که باید به scan پاس بدید ، دیگه اینبار var هستش نه var& دلیلش هم این هست که var خودش پوینتر هست به یک آدرس، شما وقتی خودش را میدی به scan این اسکن عملا میره تو همون ادرسه که var بهش پوینتر داره مینویسه، و وقتی نوشت شما برای اینکه به محتواش دسترسی داشته باشی با var* میتونی محتوایی که scan نوشته را بری دریافت کنی، در واقع انگار محتوای ادرسی که پوینتر var قبلا داشت بهش اشاره میکرد را این scan میاد تغییرش میده.
و توجه کن که این عمل خطا هم نمیده و دیباگش سخته، یعنی تو مطمئن باش که scanln همیشه باید منتظر ورودی کاربر بشینه، اما اگه محتوا مثل این قضیه پوینتر باشه، ارور نمیده ولی منتظر محتوای کاربر هم نیمشینه، یعنی باید حواست جمع باشه اگه پوینتر خواستی به scanln پاس بدی، حتما به این توجه کن که نباید var& بهش بدی و باید خود var را بدی در صورتی که اگه پوینتر نباشه، حتما باید var& را بهش بدی نه var را. پس حواست به این باشه که اگه برنامت scan یا scanln داشتی و منتظر ورودی نشد احتمالا سر همین قضیه‌ها اشتباه کاری کردی چون ارور نمیده ولی کارم نمیکنه.

÷÷÷÷÷÷÷÷÷ نکته‌ای در مورد scan و تکنیک pip کردن
اگه خواستی از کاربر ورودی بگیری با fmt.Scan میتونی فقط به نحوه‌ی نوشتن مقداری که کاربر میزنه در متغیر که با & توجه کن: 
var name string
fmt.Scan(&name)
fmt.Println(name)
بحث fmt.scanf هم هست که باز قضیه میره سراغ %d و اینا و باید به همون سبکی که منتظر هستی، قشنگ ورودی‌ها را بگیری
fmt.scanf("%d, %d, %d", &a1, &a2, &a3)
که در ورودی حتما باید به فرمت 1, 2, 3 زده بشه یعنی کاما فاصله، چون "%d, %d, %d" تعریف کردی.
یا مثلا در مثال زیر 
fmt.Scanf("%d*%d*%d", &a1, &a2, &a3)
حتما ورودی به شکل 3213*3123*1231 قبوله یا اگه به شکل زیر بود
fmt.Scanf("%d\n%d\n%d", &a1, &a2, &a3)
خودش ازت تا اینتر میزنی ورودی بعدی را تو اینتر میگیره و... خلاصه باید نحوه‌ی دادن ورودی‌هات دقیقا مطابق فرمت باشه که این یارو منتظره

حالا نکته اینه که وقتی اینطوری منتظر ورودی هست، شما میتونی از pip هم استفاده کنی یعنی مثلا:
echo 3213*3123*1231 | app.out
که در واقع الان سه تا مقداری که زدی را به عنوان ورودی‌های scanf در نظر میگیره، تازه اگه بخوای ارگومان هم بدی میتونی همه اینا را بهم ترکیب کنی:
echo 3213*3123*1231 |go run cliAppOnline.go -name=reza
که کدی که بخواد خط بالا اجرا کنه:
package main
import (
	"flag"
	"fmt"
)
func main(){
	new1 := flag.String("name", "empty", "just say hello")
	flag.Parse()
	var a1, a2, a3 int
	fmt.Scanf("%d*%d*%d", &a1, &a2, &a3)
	fmt.Printf("%d %d %d %s", a1, a2, a3, *new1)
}
در واقع این کد از تو هم انتظار پاس دادن فلگ داره هم انتظار دادن ورودی هنگام اجرا، شما میتونی فلگ پاس ندی، اگه ندادی، خودش مقدار دیفالت empty را در نظر میگیره. همچنین انتظار دادن ورودی هم داره، اگه با echo و یا کلا به هر شکلی قبل اجرا بهش ورودی‌ها را پاس بدی، دیگه فرمان ورودی را بهت نمیده، حالا اگه فرمت اشتباه بدی، که دیگه همون صفر در نظر میگیره اگه هم فرمت درست بدی، که خب عین ادم میخونه، اگه هم کلا با echo اینا پاس ندی به محض اجرای برنامه ، فرمان اجرای کنسول را میده دستت تا ورودیت را بزنی.
یا مثلا فرض کن 12*12*13 را داخل یه فایل test داریش میتونی به روش زیر بدی به برنامه‌ات :
cat test |go run cliAppOnline.go 
واسه فرمت csv , اینا خیلی به کار میاد.

÷÷÷÷÷÷÷÷÷ مبحث function value فوق‌العاده‌است.


مبحث method فوق‌العاده است.
اما method 
ورودی دادن یک نمونه به یک تابع به زیبایی و خوانایی فراخوانی اون تابع توسط اون نمونه نیست. لذا ما دوست داریم توسط خود نمونه توابع مختلف را فراخوانی کنیم که این توابع میشن متودهایی برای اون نمونه‌ها. و البت راحتی استفاده
میشه گفت golang هم oop هست بیشتر، چون من دارم به یک object هویت میدم. و عملا استفاده از struct داره به من این فرصت را میده که بتونم از پارادایم های oop تا حد خوبی استفاده کنم. چیزهایی مثل کلاس و ارث بری و اینا نداره، ولی در حین حال داریم به استراکت هامون در کنار پراپرتی هایی که دارند داریم بهشون هویت رفتاری هم میدیم، که بتونن کارهای خودشون را بکنند، مثلا استراکت دانشجو، یک هویت رفتاری که میتونه براش باشه حساب کردن شایستگی دانشجو هست، اما پراپرتی‌هاش همون نام و شماره دانشجو‌یی و ایناست

متود در ساده‌ترین حالت همان فانکشن هست فقط reciver دارد. که از مقادیر اون reciver استفاده میکنه تا یه سری کار روشون انجام بده
در واقع متودها برای تعریف رفتار برای استراکت‌ها کاربرد دارند.
قبل از نام تابع باید reciver را تعیین کنیم، که شامل یک متغیر و تایپ اون هست

شما از تایپی که تعریف کردی
یک نمونه میسازی
این نمونه‌ی تو فارغ از مقادیری که داره، میتونه از متودهایی هم که برای اون تایپ تعریف کردی اسفتاده کنه.
تو گویی یک کلاس داری شامل متود و متغیر‌ها یا به عبارتی رفتارها و پراپرتی‌ها


÷÷÷÷÷÷÷÷÷ متود در استراکتها و تفاوت پوینتر و غیرپوینتر در آن
وسط فیلم مروری بر struct جلسه هشتم
یک نکته بگم در مورد پوینتر در تعریف متودهای استراکتها.
ببین برای تعریف متود، یا ما از پوینتر استفاده میکنیم یا از مقدار استفاده میکنیم:
func (u User) test...
func (u *User) test...
اما نکته‌ای که اینجا اهمیت داره اینه، ببین شما وقتی یه نمونه‌ای از مثلا User میسازی و انتظار داری که بعدا بیای این متود خاص را call کنی به کمک اون نمونه، در این که اون متود چه کاری میخواد انجام بده، مشخص میشه که شما کپی بزاری یا پوینتر بزاری.
ببین اگه این متود، قرار هست مقادیر field های استراکت را تغییرشون بده مثلا اپدیت کنه، در این حالت صد در صد باید از پوینتر استفاده کنی، چون اگه پوینتر استفاده نکردی، و از روش کپی مقدار استفاده کردی، وقتی مثلا متود u1.test را فراخوانی میکنی، این کامپایلر میاد یه کپی از u1 و مقادیر فیلدهاش میگیره، و میزاره جای u که در تعریف متود u User گذاشتی، بعد حالا تو متود تو میای مقادیر فیلدها را تغییر میدی، وقتی از متود میای بیرون مقادیر u1 دست نخورده خواهند بود، چرا که در متود صرفا مقادیر u که یک کپی از u1 بود تغییر کرد، و بعد از اون اسکوپ متود هم از بین رفت، ولو اینکه مقادیر فیلدهاش تغییر کرده بود. اما اگه تو از u *User استفاده میکردی، در عمل u میشد پوینتر به u1 و در عمل به همون جایی اشاره میکرد که u1 اشاره میکنه، در واقع به جای اینکه u بشه کپی یک مقدار از u1. در عمل ادرس u1 ریخته میشه تو u حالا وقتی تو میای و داخل متود تغییرات انجام میدی، عملا هر فیلدی که تغییر میدی، داری فیلدهای u1 را عوض میکنی، چون فیلدهای u عملا همون فیلد‌های u1 هستند نه کپی‌شون. بنابراین وقتی میخواهی مقادیر فیلد‌های استراکت برای نمونه های مختلف را تغییر بدی، برای اینکه اعمال بشند حتما باید از پوینتر استفاده کنی.
اما ممکنه در متودی تو صرفا میخوای به مقادیر فیلد‌ها دسترسی داشته باشی، و اصلا تصمیمی برای تغییرشون نداری، در چنین حالتی مختاری که از پوینتر استفاده کنی یا از کپی مقدار، چرا که در این حالت اگه از پوینتر استفاده کردی که خب باز در عمل به اصل u1 داری اشاره میکنی و خب به مقادیرش دسترسی داری. اما در این حالت کپی مقدار هم انتظار تو را میتونه برآورده کنه، چرا که در این حالت میاد مقادیر فیلد u1 کپی میشه، و ریخته میشه تو u ، تو هم که صرفا میخواستی مقادیر را بهشون برسی و مثلا چاپشون کنی و هدفی برای تغییرشون نداشتی، لذا کپی مقادیر هم انتظار تو رو میتونه برآورده کنه.
بنابراین اگر در یک متود استراکت، تصمیم داشتید فیلد‌های استراکت را تغییر دهید مثلا اپدیت کنی، حتما باید از پوینتر استفاده کنید تا تغییراتتون اعمال بشه، چون کپی مقادیر نمیتونه تغییرات را روی فیلد‌ها اعمال کنه. اما اگه صرفا میخواستید فیلد‌ها را مشاهده کنید و تصمیمی برای تغییرشون نداشتید، در این حالت میتونید هم از پوینتر هم از کپی مقدار استفاده کنید ، تا به مقادیر فیلدها دسترسی داشته باشید.


finish
-------------------------------------------------------------------------------
|^^^| interface
در بحث interface هدف ما این هست که مجموعه‌ای از رفتار را مدل کنیم.
خیلی اوقات پیش میاد که ما برای ماژول‌هامون نیاز به نوشتن قرارداد داریم، و این قرارداد به ما کمک میکنه که یک انعطافی در برناممون ایجاد بشه، قرارداد یعنی ما بخش‌های مختلف سیستم را مجبور نکنیم فقط از یک سری کتابخونه و ابزارهای خاص استفاده کنند.
دقیقا مثلا برعکس پروژه‌ی todo cli که مجبورش کردیم تمام بخشهاش بیان و با فایل ارتباط باشند، در فایل ذخیره بشند و.. که کاملا الان وابسته شده برنامه‌ی ما به فایل
در حالی که اگر میمودیم یک قراردادی برای لایه‌ی storage می‌نوشتیم و مثلا درش میگفتیم که این لایه‌ی storge باید مثلا این چهار رفتار خاص را satisfy کنه، کار حل بود، مثلا بگیم این لایه‌ی storage یک رفتارش این باشه که بتونه اسلایسی از todo ها را به ما برگردونه، یک رفتارش این باشه که بتونه todo جدید ذخیره کنه، یا باید بتونه با شناسایی یک todo اطلاعاتش را به ما پاس بده و... و با این کار کل سیستم را به یک فایل وابسته نمیکردیم بلکه یک لایه‌ی انتزاعی ایجاد میکردیم که در آن تعیین کنیم که چه رفتاری مورد انتظار ما هست،  و وقتی این لایه‌ی انتزاع اوکی شد، حالا میشه از هر کتابخونه یا ابزاری که میخوایم برای این لایه‌ی ذخیره‌سازی استفاده کنیم به شرط اینکه بتونه انتظارات این لایه را satisfy کنه، چه فایل باشه، چه هر چیز دیگه و اینطوری به جای اینکه برنامه‌ ما وابسته به اون ابزار یا کتابخونه‌ی خاص بشه، از این وابستگی خارجش میکنیم، مثل قبل که برنامه‌ی ما وابسته به فایل شده بود و ما به کمک این لایه‌ی انتزاع یا دقیق‌ترش این قرارداد کاری کردیم که اون کتابخونه یا ابزار خاص خودش را با اون قرارداد ما وفق بده تا بتونه با برنامه‌ی ما کار کنه، و اینطوری انگار اون وابسته شده به برنامه‌ی ما ، چون اگه بخواد به کار ما بیاد باید شرایط ما که همون قرارداد ما هست را رعایت کنه. و این مصداق وابستگی هست. اینطوری دیگه به جای این که بگیم ما داریم اسلایسی از todo ها را در فایل ذخیره میکنیم، میگیم ما نیازمند یک لایه‌ی storage هستیم که یکی از رفتار مورد انتظار ما ذخیره کردن لیست todo ها در آن هست، حالا هر شکل ذخیره‌سازی‌ای اگه بخواد به کار برنامه‌ی ما بیاد، باید خودش را با ما وفق بده و اون انتظارات را برآورده کنه، در صورتی که قبلا ما میگفتیم لیست در فایل ذخیره بشه، و وقتی کد را میزدیم، مصداق وابستگی برنامه‌ی ما به فایل در برناممون موج می‌زد.

به این تغییر رویکرد  در وابستگی میگند، dependency INversion یا وارونگی وابستگی. که در واقع وابستگی ها را ما به خودمون وابسته کردیم. به جای اینکه ما به وابستگی‌ها، وابسته باشیم، که این کار باعث کاهش ترس از تغییر خواهد شد.

در واقع در حالتی که وابسته به مثلا فایل باشیم، انعطاف پذیری برنامه را به شدت کم کردیم، یا باید یک ریسک خیلی بزرگی را به جون بخریم برای تغییر دادنش، که خب این دقیقا خلاف cost of change یا fair of change هستش که یعنی هزینه‌ی تغییر بالا هست و من باید به عنوان مهندس نرم‌افزار به فکر یک راه چاره باشم
حالا اینجا صرفا یک وابستگی ذخیره سازی بود،‌که ما گیر فایل افتاده بودیم. حالا شما فرض کن برنامه‌ای که شامل انواع وابستگی ها هست از ذخیره سازی گرفته تا چیزهای دیگه، و همه‌ی اینها میتونه این هزینه‌ تغییر را سرسام اور کنه و گاهی اوقات نشدنی
اینجاست که میگیم اقای وابستگی مثلا ذخیره‌سازی، من به تو وابسته نمیشم، تو به من وابسته میشی و این کار به کمک تعریف قرارداد(interface) داخل برنامه صورت میگیرد، و داخل اون مشخص میکنم که اقای وابستگی حافظه، تو هر کی میخوای باش، من انتظار این رفتار خاص را ازت دارم، اگه این رفتار را داریشون که عالی، تو از الان به من وابسته‌آی ولی اگه نداری، برو اول انتظارات من و برآورده کن، که وابسته به من بشی و بعد بیا تا ازت استفاده کنم. 
در واقع منه برنامه به این قرارداد وابسته‌ام که هیچی نیست جز تعریف رفتارهایی که مورد نیازم هست، هر کسی میخواد بیاد مثلا در این مثالمون کار ذخیره‌سازی را برای من بکنه باید مفاد این قرارداد را رعایت کنه، اگه کرد، شایستگی اینکه من ازش استفاده کنم را خواهد داشت، و با این کار اون بخش ذخیره‌سازی هم داره وابسته میشه به این قرارداد و مفادش.

پرانتز خارج بحث (منظور از inMmemory، ذخیره‌سازی در خود برنامه هست، که دقیقترش میشه ذخیره‌سازی در RAM زمانی که برنامه در حال اجرا هست، که با هر بار بستن برنامه هر چیزی ذخیره‌سازی کرده بودیم از بین خواهد رفت، مثل ذخیره کردن در یک اسلایس یا ذخیره کردن در یک map و هر دیتااستراکچر دیگری در برناممون)

حالا این قرارداد چی هست؟ فایله؟ inMemoryیه؟ دیتابیسه؟ نه هیچ کدومش نیست، صرفا یک انتزاع و یک چیز رو هوا هست و به هیچ چیز دیگه‌ای وابسته نیست، و هیچ کاری هم نداره پشت صحنه چیه، فقط صرفا یک سری متد درش مشخص شده، که هر کسی فارق از اینکه چی هست، اگر خواست شرایط قرارداد را satisfy کنه، باید این رفتار را همشون(تاکید میکنم) همشون را پیاده کنه، اگه رفتاری بیشتر داره، مشکلی نیست ولی اون رفتار بیشتر نه مزیتی داره و نه به کار من در این برنامم میاد فقط همونهایی که لازم دارم، قابل استفاده است.
مثلا برای لایه‌ی ذخیره‌سازی ما میریم یک قرارداد می‌نویسیم برای برناممون و یک سری انتظارات مشخص می‌کنیم، حالا هر چیزی چه فایل باشه دیتا دیتابیس، چه inMemory اگه بخواد به عنوان لایه‌ی ذخیره‌سازی من باشه، باید بره مفاد این قرارداد که همون رفتارها مورد انتظار من هست را پیاده کنه. مثلا یک نمونه قرارداد:
type UserStore interface {
	CreateUser(u user.User)
	ListUsers() []user.User
	GetUserByID(id int) user.User
}
الان این قرارداد که به صراحت در برنامه من تعریف شده، میشه کل لایه‌ی ذخیره‌سازی من، حالا هر چیزی چه فایل چه inMemory چه database اگه بخواد بیاد و نقش لایه‌ی ذخیره‌سازی من را بازی کنه باید تمام این سه متد را دقیقا با همین سیگنچرها پیاده‌سازی کنه و هر رفتارش دقیقا همین چیزهایی که من میگم را بگیره و چیزهایی که من میگم را برگردونه، اگه این کار را انجام داد، می‌تواند به عنوان لایه‌ی ذخیره‌سازی من مورد استفاده قرار گیرد.
و نکته جذاب اینجاست هزینه‌ی تغییر اینکار مثلا رفتن از یک روش inMemory جدید به جای inMmeomry فعلی یا استفاده از فایل به جای inMemory و کلا هر جایگشت دیگه‌ای،‌ در بخش APP که هیچ تغییری نداریم، فقط و فقط یک خط در main باید تغییر بدیم که main هم جایی هست که قراره کامپوننت های مختلف برنامه را بهم وصلشون کنم و من اونجا صرفا دارم یک خط تغییر میدم. و کل هزینه‌ی  تغییر من، تغییر یک خط در main هست، و نه حتی تغییر در بیزینس لاجیکم که در APP هست، حالا فرض کن به جای این کار من وابسته بودم به فایل، اگه یه درصد میخواستم به جای فایل برم سمت inMemory، باید کل بیزینس لاجیکم که در APP پیاده شده را میکوبیدم و تغییر میدادم و به جای فایل خودم و وابسته میکردم به inMemroy.
	
بحث composition over inheritence :  
سوال این هست که در زبانهای oop وقتی که شما میای و یک interface تعریف میکنی. بعدا فرض کن یک کلاس(که در زبان گو همون استراکت ببینش) میای تعریف میکنیم که مثلا میتونه این interface را و انتظاراتش را saticfy کنه، در تعریف این کلاس میان دقیقا می‌نویسند که اقا این کلاس پیاده‌سازی شده تا interface های گفته شده در سیگنچر کلاس را اوکی کنه. که تحت inherit کردن هم یاد میشه مثلا میگن کلاس A پیاده شده تا interface B را بتونه انتظاراتش را برآورده کنه. با این کار خب یه خوبی این هست که من میدونم این کلاس خاص برای چه هدفی پیاده شده و واضح گفته شده که انتظارات این interace خاص را میتونه برآورده کنه. اما یک عیب بزرگ داره، که من این تایپ جدیدم که کلاسم هست را دارم صرفا محدودش میکنم به اون interface یا مجموعه‌ای از interface ها و دیگه استفاده‌ای دیگه ای ازش نمیتونم بکنم .
در صورتی که در go ما نمیایم در استراکت حرفی از interface هایی که میتونه saticfy کنه بزنیم و در واقع ما میایم استراکت را به طور ضمنی و نه صریح مرتبطش میکنیم به interface. و اصلا ما نمیایم یه استراکت تعریف کنیم، صرفا برای اینکه مثلا اون interface خاص را اوکی کنه، با این کار جذاب، این استراکت هزار تا استفاده میشه ازش کرد، یعنی فرض کنید چهار تا رفتار برای این استراکت تعریف کردیم، سه جور interface مختلف داریم، یکیشون دو تا رفتار مدنظر داره، یکیشون سه تا و یکیشون هم صرفا یک رفتار، تمامی این رفتارهای این interface ها، جز همون رفتارهایی هست که در این استراکت تعریف شدند، یعنی این استراکت می‌تواند، تمامی interface های فوق را saticfy کنه، تازه ممکنه در آینده یه interface دیگه بسازیم که اونم متودهایی که انتظار داره، باز این استراکت ما همشون را saticfy میکنه، لذا این که به شکل صریح نیایم بگیم اقا این استراکت مال این یک یا چند تا interface خاص هست، دست ما را باز میزاره، که هی بتونیم از استراکت‌هامون استفاده کنیم و وابستشون نکنیم به یک interface خاص.
در واقع ما اینطوری استراکت می‌نویسیم با انواع متدها و با خیال راحت میتونیم ازش برای انواع interface های مختلفی که پیاده شده یا پیاده‌ خواهند شد، در صورتی که متدهاشون را saticfy میکنه، استفادش بکنیم.
مثال:
مثالش برای interface io.Reader و مثلا bufio.NewScanner که داره از این استفاده می‌کنه در دقیقه ۱۱ به بعد معرفی interface قسمت دوم 
و مثال sort.Sort هم از دقیقه ۲۲ همین فیلم بالا

ترکیب inteface ها 
میشه interface ها را با هم ترکیب کرد، مثلا ReadWriter یک interface در ماژول io هست که تعریفیش در ماژول io به صورت زیر هست:
type ReadWriter interface{
	Reader
	Writer
}
عملا در این قرارداد مشخص شده که رفتارهایی که مورد انتظارش هست، هم رفتارهایی هست که در اینترفیس Reader مورد انتظار هست، هم رفتارهایی هست که در اینتفریس writer مورد انتظار هست. در این صورت اگر تایپی داشته باشیم که هم متدهای reader هم متدهای writer را بتونه saticfy کنه، در نتیجه می‌تواند اینترفیس ReadWriter را هم saticfy کنه.
همین قضیه برای استراکت:
این قضیه ترکیب کردن،‌برای struct ها هم هست، یعنی اگه یه استراکت تعریف کردی و در تعریفش اسم یک استراکت دیگه را آوردی، یعنی این استراکت جدید، رفتارها و پراپرتی‌های اون استراکته را هم داره.

قبلا هم گفتم اگه یک struct یا هر دیتاتایپی میخواد متودهای یک interface را saticfy کنه، باید همشون را پیاده کنه؟
قطعا همینطوره، اگه حتی یکی از متودهای مورد نظر را نتونه ارضا کنه، دیگه به درد اون interface نمیخوره، البته اگه متودهای بیشتری داشته باشه مهم نیست


تفاوت struct با interface
گفتیم استراکت می‌تواند شامل پراپرتی‌های مختلف باشد و همچنین ما میتوانیم برای استراکتمون بیایم و رفتار‌های مختلفی را هم تعریف کنیم و در نتیجه یک استراکت می‌تواند شامل پراپرتی‌ها و رفتار‌های مختلفی باشد یا نباشد. و اینجوری من مدلسازی خودم را که شامل پراپرتی و رفتارها هست انجام دادم، و کسی که میاد از این مدل استفاده کنه، این مدل با پراپرتی و رفتارش هست که براش مهم هست.
اما گاهی اوقات پیش میاد که من هیچ دغدغه و محدودیتی روی پراپرتی‌ها ندارم. و تنها هدف من برای مدلسازی این هست که رفتار مشخصی را بیام تعیین کنم و اصلا کاری ندارم که چه پراپرتی‌هایی این وسط دخیل هستند. چیزی که برای من اهمیت داره این هست که اون کسی که میخواد از مدلسازی من استفاده کنه، اون رفتاری که من انتظار دارم را پیاده کرده باشه.


هر جا که ورودی تابع یا ماژول ما میخواد کاری را انجام بده و یک وابستگی داره(ورودی داره) و براش اهمیتی نداره که اون وابستگی چه خصوصیات و پراپرتی‌هایی داره، فقط تمرکزش روی این هست که اون وابستگی،‌ یک یا مجموعه‌ای از رفتار مشخص را داشته باشه، اونجا ما از interface استفاده میکنیم. 
الان مثلا تابع deactivateUser2 تابعی هست که براش فرقی نداره ورودیش از چه جنسی هست و اصن کیه فقط براش مهمه که رفتار deactivate را پیاده کرده باشه،‌ در این حالت میگیم پس جنس ورودی را ما یک interface تعریف میکنیم که در واقع یک لایه‌ انتزاعی یا دقیقترش قرارداد هست که در اون مشخص می‌کنیم باید حتما رفتار deativate را پیاده کرده باشه. 

کجا از اینترفیس استفاده کنیم؟ جایی که داریم رفتاری را general میکنیم میریم سراغ اینترفیس، مثلا اگه یه مدل(استراکت) یوزر داریم که رفتاری را براش درنظرم هست داشته باشه، خب میرم یه متود برای همون استراکت تعریف میکنم و لازم به اینترفیس تعریف کردن و بعد ارتباط بین این اینترفیس و استراکت نیست، اما اگه چند مدل یوزر مختلف داریم که همشون قرار هست اون رفتار خاص را داشته باشند، میرم و اون رفتار را general میکنم، یعنی interface ای براش تعریف میکنم و در اون میام این رفتار را تعیین میکنم، در این صورت این interface میتونه برای تمامی اون دیتا تایپهای مختلف پوشش داده بشه.
حالا برای اینکه این رفتار general همه گیر تر بشه و دیتا تایپ های بیشتری بتونند، نیازمندی interface را saticfy کنند. معمولا interaface ها خیلی کوچیک هستند، یکی دو تا متود بیشتر ندارند. البته داشتن متودهای بیشتر ایرادی نداره ولی خب ممکنه جامعیتش را محدود تر کنه و دیتا تایپ های زیادی نباشند که اون interface را saticfy کنند.


در گولنگ چیزی به اسم ارث بری نداریم.
بحث error wrap
یه ارث بری ریزی دقیقه اخر سوال و جواب گفت.
خود interface سوال هست هنوز


finish
-------------------------------------------------------------------------------
|^^^| new Concept

÷÷÷÷÷÷÷÷÷ بحث cloud
مجموعه بی‌نهایتی از resource ها را میشه گفت همون cloud هست. در حالت سنتی ما یک یا چند تا سرور داشتیم که دغدغه‌ی ما بود. ولی در ابر دغدغه‌ی ما تعداد منابعمون نیست.

÷÷÷÷÷÷÷÷÷ بحث cloud native 
یعنی اوکی حالا که دغدغه منابع نداری ولی من ازت میخوام برنامه ای بنویسی که cloud friendly باشه، یعنی رو ابر بشه خوب ازش استفاده کرد. چون بکند داره میره سمت cloud native و انقلاب داره توش رخ میده برای همین go برای بکند هم خوب شده.

÷÷÷÷÷÷÷÷÷ بحث single responisibilty یا SOLID
یک سوالی مطرح شد: آیا میشه وقتی کاربر میخواد تسک‌های امروز را ببینه، و همچنین وقتی میخواد تسک های یک روز خاص را ببینه، این دو را با هم تجمیع کنیم؟
یعنی صرفا تاریخ مشخص بشه و بعد تسک های اون تاریخ برگردونده بشه، کاری هم نداشته باشیم که امروز هست یا یه تاریخ دیگه ؟
توجه بشه که صراحتا در دیزاین به ما دو تا نیازمندی گفته، گفته لیست کردن تسکهای امروز یک نیازمندیه و لیست کردن تسکها بر اساس تاریخشون، یک نیازمندی دیگر.
اگر فنی به قضیه نگاه کنیم، میگیم بله یک تابع میزنیم که صرفا تاریخ بگیره، و تسک برگرونده ، حالا چه امروز باشه چه تاریخ مال زمان خاصی باشه، ما یا تاریخ امروز را میدیم یا تاریخی که مدنظر کاربر هست.
اما این دیدگاه غلطه : چرا؟
چون ممکنه بعدا کاربر پاشه بیاد بگه اقا یادته یه نیازمندی‌های من این بود که تسک‌های امروز را بهم برگردونی، من میخوام تو اون صفحه که تسک‌هاامروز برمیگشت، مثلا زمانی که باقی‌مانده تا ددلاینشون هم تموم شه را بگی ، یا یه چیز دیگه، مهم این هست که یک نیازمندی‌ جدید میاد در راستای نیازمندی‌ای که قبلا گفته بود به ما میده، در واقع ما در صفحه‌ی تاریخ بده تا لیست تسک بدم، ما این نیازمندی را نداریم، در صورتیکه در صفحه‌ی لیست تسک های امروز این نیازمندی اضافه شده.
لذا ترکیب کردن اینهایی که صراحتا براشون نیازمندی داریم کار اشتباهی هست. و کار خودمون را سخت میکنه
به این میگن single Responsibility که بهش میگن SOLID یعنی هر فانکشن یا متود باید یک عامل یا دلیل برای تیغیر داشته باشد. اگر من یک تابع بنویسیم،که هم تسک‌های امروز را هندل کنه، هم تسک‌های با تاریخ  را ، عملا دو تا عامل داره
لذا بهتر است این single responsibility در همه‌ی لولها اپلای بشه. از لول فانکشن و متود تا لول بالاتر.

÷÷÷÷÷÷÷÷÷ بحث Sanitize کردن، یعنی صحت و درستی اطلاعات را قبل از اینکه به اون مرحله‌ی اسفتاده برسه، بررسی کنیم. مثلا validation یک نوع از sanitize هست، یعنی اینیملی که داری میدی درسته یا نه یه چیز کشکی ندی. عموما در جاهای مختلف پروژه ما بخش‌های مختلفی میزاریم که اطلاعات را بیاد Sanitize کنه . این کار خیلی بهتر از این هست که بیایم defencive programming کنیم، یعنی من از اکسپشن و باگ خوردن میترسم  ، هر چیزی که دمه دستم میاد را میخوام چک کنم (دقیقه ۱.۱۳ فیلم ۵.۲) باید ساختار و روند پروژه را جوری بچینیم که مطمئن باشیم اطلاعات Sanitize میشند و هر بخش نگرانی دیگه نداشته باشیم اطلاعاتی که داره میاد همونی هست که ما انتظار داریم یا خیر 
 

÷÷÷÷÷÷÷÷÷ بحث transparency در برنامه‌نویسی هر چه شفافتر باشید بهتره، کلا ما شفافیت‌های مجزا داریم، یک بخشش سمت کاربر هست که میفهمه مشکل چی بوده، یک بخشش سمت خودمون(یعنی سرور) هست که باعث میشه خطایابی و تریس برنامه راحت بشه. و برای اینکار ممکنه یک سری چیزارا لاگ کنیم، برای این کار خوبه که شفاف باشیم.
اما این وسط ما بعد امنیت را هم سمت بکند داریم. کاربر را صرفا گل و بلبل نبیندید یه هکر عوضی ببینید، لذا شفافیت سمت کاربر باید به سمت مبهم بودن پیش بره، ینی اقا مثلا نام کاربری یا رمزت غلطه ولی براش مشخص نکنید که کدومش دقیقا غلط بوده

÷÷÷÷÷÷÷÷÷ بحث interpolation یعنی شما بتونید کدهای یک زبان را در یک زبان دیگه اجرا کنید. 

÷÷÷÷÷÷÷÷÷ بحث varialbe shadowing که وقتی یک var در اسکوپ بالاتر تعریف میکنی، اگر در اسکوپ های داخلی مجددا همون var را مثلا با =: تعریف کنی، تو گو بهت اجازه میده و این خوب نیست، پس باید حواستو جمع کنی که اشتباه نکنی سر این قضیه 
سر err هم همین قضیه است توصیه خود استاد اینه که err جدید بزاری

÷÷÷÷÷÷÷÷÷ قابلیت رفلکت reflect قابلیت خوبی هست ولی بهتره ازش استفاده نشه، سر اینکه %v از کجا تایپو میفهمه مطرح شد، ولی توضیحش برای بد گفته شد.

÷÷÷÷÷÷÷÷÷ بحث hashing 
و اینکه پسورد ها را در قالب هش ذخیره کنیم، بسیار اهمیت داره، که اگر دیتابیسمون به خطر افتاد نیومده باشیم پسوردها را در قالب plain گذاشته باشیم و در واقع هش‌ها به دست مهاجم بیفته، با هش ها هم نمیتونه به پسورد اصلی برسه، مگه اینکه اومده باشه تمامی حالت‌های مممکن پسورد را براش هش درست کرده باشه و حالا بیاد هش ها را مقایسه کنه اگه تطابق داشت میفهمه کدوم پسورد هشش این بوده. که خب عملا در زمان معقول نمیتونه به این برسه، لذا با این که هش ها میفته دست مهاجم ولی کاری از پیش نمیتونه ببره، البته به شرطی که تابع هش خوبی استفاده کرده باشه، در نظر هم داشته باش که توابع هش یک طرفه هستند یعنی از هش نهمیتونی به پسورد برسی، تنها راهش همونطور که گفتم ، مقایسه و سعی و خطا هست و گرنه از هش نمیشه به پسورد رسید. در قسمت package ها برای go توابع هش مختلف را اوردم.


÷÷÷÷÷÷÷÷÷ بحث serialization و deserialization
The process of converting your data into a stream of bytes is called serialization. The process of reading a data file and converting it into an object is called deserialization.
The encoding/gob standard Go package will be used for the program kvSaveLoad.go. It will help the serialization and deserialization process. The encoding/gob package uses the gob format for storing its data. The official name for such formats is stream encoding. The good thing about the gob format is that Go does all of the dirty work, so that you don't have to worry about the encoding and decoding stages.
Other Go packages that can help you serialize and deserialize data are encoding/xml, which uses the XML format, and encoding/json, which uses the JSON format.

÷÷÷÷÷÷÷÷÷ بحث serialization
کلا serializtion را برای این نیاز داریم که یا دیتا را persist (ذخیره) کنیم یا بخوایم منتقلش کنیم.
یکی از انواع این serialzation ها json هست که اکثر زبان‌ها پشتیبانی میکنند ازش که در اینجا میشه این
data, err = json.Marshal(&newUser) --> newUser: var struct - data: []byte
err = json.Unmarshal([]byte(data), &newUser) --> newUser get data if not err
برای xml هم دقیقا همین ساختار را داریم به جای json ها بزار xml
برای csv هم ساختار داریم اما خودت بیای استراکت مولفه‌هاش را با هم در یک رشته با جداکننده کاما کنار هم بنویسی، روش بهتریه در مثال زیر اینکار و انجام دادم فقط خودم تهش خواستم رشته نهایی را تبدیل به اسلایسی از بایت‌ها کنم.
data = []byte(fmt.Sprintf("%s,%d,%s", newUser.Email, newUser.ID, newUser.Password))

÷÷÷÷÷÷÷÷÷ تفاوت encoding , serializtion
باید توجه داشت که encoding یک دسته‌ی بزرگتری از serializtion هست. در واقع serializtion میشه جزیی از encoding و در واقع میشه گفت تمامی این serializtion ها encoding حساب میشند.

در واقع serializtion ها برای تبدیل کردن یک object (مثل استراکت) داخل مموریمون به یک رشته‌ای(در واقع رشته‌ای از بایت‌ها) که قابل سیو کردن یا ترانسفر کردن هست تبدیلش کنیم. در مقابل encoding فقط مخصوص این نیست که ‌object را تبدیلش کنیم به یک رشته‌ای از بایت ها، بلکه در کنار این کار، میتونه هر رشته‌ای از بایت‌ها را به هر‌ رشته‌ای از بایت‌ها تبدیل کنه. که برای مثال gob که مال خود golang هست یک encoding هست هم یه ojbect را به یک اسلایسی از بایت تبدیل میکنه هم اسلایسی از بایت را به یک اسلایس دیگری از بایت تبدیل میکنه.
encoding: convert a stream of bytes to another stream of bytes
serialization: convert an object/struct to stream of bytes

÷÷÷÷÷÷÷÷÷ بحث تست یا testing
فیلم جلسه ۶ بخش new
ما به لاجیک هایی که مینویسیم اصلا مطمئن نیستیم ، گاهی اوقات به شکل دستی میریم تست کنیم ولی این واقعا کافی نیست برای ما و به ویژه برای حالت های مختلف برناممون، اگه که برناممون ورودی و خروجی های زیادی را شامل میشه.
لذا یکی از روش‌های خوبی که میشه به کار گرفت استفاده از تست هست، که بتونیم باهاش تعداد زیادی از ورودی ها را تست کنیم

این تست نویسی fair of change یا ترس از تغییر را کم میکنه. در واقع اگه دارم کد را تغییر میدم کجاها ممکنه بترکه.
این روش تست نویسی اصولا جاهایی استفاده میشه که داریم از یک سری توابع ابزاری(کمک کننده) می‌نویسیم. که ممکن هست خیلی جاها استفاده بشند. مثلا تبدیل رشته به int که ممکنه هزار جا استفاده بشه، پس خوبه که براش تست بنویسیم.

توابع utility function یا  helper function که توابعی هستند که زیاد در برنامه استفاده میکنیم ازشون و یک خدمتی را به ما میدن.

در گولنگ برای بحث تست نویسی:
در گام اول میگه برای فایلی که میخوای تستش کنی، بیا یه فایل تعریف کن در همون مسیر و خب قاعدتا همون پکیج هم باید باشه چون در یک مسیرند.
اسم فایل را هم بزار اسم همون فایلت به همراه test.go_ الان مثلا برای فایل main امون اگه خواستیم فایل تست و اوکی کنیم فایل تستمون در همون مسیر میشه main_test.go
گام دوم: پکیج testing را import کن در فایل تست و ببین چه تابعی را میخوای از فایلی که داری تست میکنی، تستش کنی؟ هر تابعی هست در فایل تست هم بیا، یک تابع تعریف کن، که شروع اسمش Test هست و اسم تابع هم ادامش بزار ، و ورودی این تابع هم همواره t *testing.T خواهد بود. که t که یک اسمه که هر چی میتونه باشه و  در واقع یک پوینتز از جنس T هست که خود T در پکیج testing قرار داره، توجه کن که T در پکیج testing عملا یک استراکت هست، پس در عمل t میشه یک پوینتر از جنس استراکت T که در پکیج testing تعریف شده است. 
بنابراین اگر مثلا خواستم تابع square در فایل main را تست کنم، تابع زیر را در فایل main_test.go تعریف خواهم کرد:
func TestSquare(t *testing.T){}
گام سوم، شما داخل تابع بیا تابعی که میخوای تست کنی برای ورودی های مختلف به کمک حلقه زدن مثلا، تست کن و جوابی که خودت انتظار داری را با جوابی که تابع میده مقایسه کن، و در صورتی که جواب غلط هست از همون t استفاده کن که ارور برگردونی مثلا در مثال زیر اومدیم برای squere تست نوشتیم:
func TestSquare(t *testing.T) {
	for i := 1; i < 1000000; i++ {
		result := square(i)
		if result/i != i {
			t.Errorf("expected: %d, result: %d\n", i*i, result)
		}
	}
}
خب بعد که تست را نوشتی، برای اینکه تست را ران کنی کافیه از دستور go test استفاده کنی، و فایل مدنظرت و بهش پاس بدی، خودش میره تست را انجام میده و نتیجه را بهت برمیگردونه، اگه به خطا بخوره که خطا میده اگه هم درست باشه که پیغام موفقیت میده.
اگه از دستور  . go test
استفاده کردی میره تمامی فایل‌های تستی که در مسیر اصلی هست را شروع میکنه تست کردن که خب این که از کجا میفهمه هم از اون test.go_ هست در واقع هر فایلی که به این  test.go_ ختم بشه، همونی هست که مدنظر کامپایلر هست که بره go test را براش اجرا کنه.

یک نکته توجه کن در مثال بالا فرق t.Errorf و t.Fatalf :
اگه go test را اجرا کنی و به خطا بخوره،  t.Fatalf  پیغام را چاپ میکنه و پروسه تست را میبنده. اما t.Errorf اگه بزاری، اگه به خطا بخوره، خطا برمیگردونه ولی پروسه تست را ادامه میده و در واقع تمامی خطاهایی که تو اون بازه‌ای که مشخص کردی که تست روش انجام بشه را بهت برمیگردونه و مثل Fatal با اولین خطایی که برخورد کنه پروسه قطع نمیشه.

بحث table test ها : خیلی جاها اینقدر شیک و شکیل نیست که بیای مثلا یک for بزنی، رو حالتهای مختلف، گاهی مجبور هستی که دستی بنویسی یا مثل مثالی که در ادامه میدم خودت بیای مثلا استراکت تعریف کنی برای حالت های مختلف و ... که به این حالت که در ادامه نمونش را اوردم میگن table test ها .
با این حال در همین حالت‌هام اگه تعداد زیاد بود لازم نیست مثلا هر صد هزار تا حالت و بری براش تست بنویسی، از کورنر کیس ها ( اونجاهایی که خطا احتمال میدی رخ بده چه میدونم مثلا صفر یا عدد منفی یا هر چیز دیگه ای) اونارا حتما بزار از حالتهای عرف هم یه چند تا رندم تست براش بزار، لازم نیست برای همشون بری اینکار و انجام بدی ولی کورنر کیسها را حتما بزار
func TestDayOfWeek(t *testing.T) {
	type test struct {
		Input          int
		ExpectedResult string
	}

	var testCases = []test{
		{Input: 1, ExpectedResult: "شنبه"},
		{Input: 2, ExpectedResult: "یکشنبه"},
		{Input: 3, ExpectedResult: "دوشنبه"},
		{Input: 4, ExpectedResult: "سه شنبه"},
		{Input: 5, ExpectedResult: "چهارشنبه"},
		{Input: 6, ExpectedResult: "پنجشنبه"},
		{Input: 7, ExpectedResult: "جمعه"},
		{Input: 8, ExpectedResult: ""},
		{Input: 0, ExpectedResult: ""},
		{Input: -1, ExpectedResult: ""},
	}

	for _, c := range testCases {
		result := dayOfWeek(c.Input)
		if result != c.ExpectedResult {
			t.Errorf("expected: %s, result: %s\n", c.ExpectedResult, result)
		}
	}
}

این تست‌هایی که نوشتیم همگی unit test بودند که یک واحد کوجیک مثل یک تابع را اومدیم برای ورودی مختلف خروجیش را تست کردیم.

÷÷÷÷÷÷÷÷÷ فضای heap , stack
یک لینک خوب:
 https://medium.com/eureka-engineering/understanding-allocations-in-go-stack-heap-memory-9a2631b5035d
به ویژه بخش زیر در لینک بالا:
The stack and heap we know and love
توجه باید بکنی که بحث هیپ و استک تقریبا در گو هم مثل بقیه جاهاست که اقا استک حین برنامه به کار میره و هیپ فضاهایی هست که شما نیاز به رفرنس داری و یه جورایی باید فیکس باشه که تو به آدرسها و محتوای اونها دسترسی بگیری، در صورتی که در استک تو گیری در ادرسها نیستی و این استک میاد پوش و پاپ میشه حین اجرا و خب داینامیک هست و لزومی هم به فیکس بودن نیست. 
اما توجه کن هر رفرنس دادنی هم با هیپ نیست که یه مثالش در همون لینک بالا هست و یه نکته ی خیلی مهم این هست که این فضای هیپ گرفتن یه اور هد عجیبی روی تعداد عملکردهای cpu میزاره، یکی از دلایلش مثل اینکه بحث Garbage collector هست، چیزی که متوجه شدم اینه که فضای استک چون خیلی سیف میاد پوش و پاپ میکنه فضا را و مشکل فرگمنت و این داستانا نیست اصن گاربیج کالکتوری لازم نداره که بعدا بیاد رفرنس‌هایی که حالا دارن به چیزای چرت اشاره میکننو پاک کنه، برعکس در هیپ خب شما میای فضا ها را میگیری و ممکنه بعدا که کارت تموم شد اینا گاربیج بشن و باید این  GC داخل گو ران بشه که این گاربیج ها را جمع بکنه و این اورهد سی‌پی‌یو هست که ایجاد میشه. البته مسلما free کردن دستی فضاهایی که گرفتی میتونه به کاهش این کار کمک کنه البته باید چک بشه که اگه من دستی free کردم این GC میفهمه یا باز چون فضایی از هیپ بود کاری نداره و مجدد ران میشه که بگرده.
من بخوام free کنم کافیه ادرس اون فضا را مساوی با  nil  بزارم.
اینم یه توضیح از گو:
Go has garbage collection. It will scan for data that has no pointer to it and remove it from heap (Garbage collector is running beside your program).
در کل نتیجه‌ نهایی این هست که استفاده از هیپ مثل اینکه خیلی توصیه نمیشه چون بحث‌هایی مثل اورهد GC را به دنبال داره، و این یعنی کلا استفاده از پوینتر خیلی توصیه نیمشه چون وقتی بحث پوینتر و اهمیت ادرس به میان میاد ، ما مجبوریم سراغ هیپ بریم که ادرس‌ها فیکس باشند و مثل استک داینامیک نباشند که بشه همه تخم مرغها را تو یه سبد چید.

یه نکته نهایی هم که به بخش benchmark بعد مربوط هست، اگه پارامتر benchmem را پاس دادی که تست کنی
go test -bench . -benchmem
دو تا مقدار دیگه مربوط به حافظه بهت برمیگردونه:
8 B/op  1 allocs/op
این که کجاها صفر هست و کجا غیر صفر و مطمئن نیستم. یه چیزی پایین نوشتم ولی مطمئن نیستم.
که این دو مقدار تنها در صورتی که برنامه ات از حافظه‌ی هیپ استفاده کرده باشه مقدار خواهند داشت و اگر کل برنامت براساس حافظه‌ی استک بوده باشه ، این دو مقدار مقدارشون صفر خواهد بود.


÷÷÷÷÷÷÷÷÷ بحث benchmark
فیلم جلسه ششم
https://www.practical-go-lessons.com/chap-34-benchmarks


