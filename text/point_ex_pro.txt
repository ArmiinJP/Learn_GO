÷÷÷÷÷÷÷÷÷ پروژه‌ی agency
بهتره که اسم پکیجها جمع نباشند.
اگه چندتا اسم هست همه را به هم بچسبون و با همون حروف کوچیک : arminjafarpisheh
-----------------
اسم فایلها همگی با حروف کوچیک باشند
-----------------
ترجیح این هست اسم پکیج و اسم فولدرش با هم یکسان باشند.
-----------------
مدل و entity خیلی جاها با هم تفاوتی ندارند اما بهتره تفاوتشون را بدونی:
توجه کن مثلا در دیتابیس ما افزون بر مقادیر، احتمالا متغیرهایی مثل createdAt , UpdatedAt هم داریم که زمان نوشتن در دیتابیس و... هست خب اگه بخوایم مدلی طراحی کنیم باید منطبق باشه با اون دیتابیسی که میخوایم باهاش کار کنیم. در صورتی که من در لاجیک خود برنامه ام اصن از این دو تا برای نمونه هیچ استفاده ای ندارم و لازم نبود اضافه بشه. لذا در اینجاها ما میایم مدل تعریف میکنیم که ممکنه یه سری فیلدهای بیشتری نسبت به entity اصلی موجود در برنامه امون داشته باشه و برای ارتبطا با دیتابیس برای نمونه خواهد بود.
و یک entity model خواهیم داشت که موجودیتی هست که در برنامه پیاده کردیم و بهش احتیاج داریم و دقیقا چیزهایی هست که در لاجیک برنامه بهشون احتیاج داریم و لازم نیست دیگه چیزهای اضافه‌ای مثل crreatedAt داخلش اضافه بزاریم.
لذا این میشه تفاوت مدل و entity 
لذا توصیه میشه همه جا همون entity را بزاریم که میشه هسته‌ای ترین موجودیت های من که بیزینس لاجیک هول محور اونها قرار داره.
-----------------
هنگام نوشتن متود، واسه قبل نام تابع که داری برای استراکت مربوطه مینویسی، بهتره که اسم کوتاه بزاری چون متودی که مینویسی برای این استراکت هست و کل فضایی که کار میکنه تو همین اسکوپ هست، لذا مثلا:
func (s *Storage) Write(data byte) errorr
همین s کافیه.
-----------------
مهمه: بستن فایل که خیلی مهمه 
اما خب عموما بستن فایل را با defer انجام میدیم.
مشکل اینجاست چون defer file.Close میزاری، اگه احیانا ()file.Close به خطا بخوره، هندل نمیتونی بکنیش، یک راه برای حل این مشکل روش زیر هست:
defer func(){
	err := file.Close()
	if err != nil {
		fmt.Printf("cant close file:%v, err)
}()
الان با این روش از defer کمک گرفتی، وقتی نوبت به defer برسه، تابع func هم تعریف و به خاطر () که اخر کار گذاشتیم، تابع اجرا هم خواهد شد. و در صورتی که file.Close با خطا مواجه بشه، به ما برمیگردونه.
-----------------

÷÷÷÷÷÷÷÷÷ پروژه‌ی toDoList

در قدم اول اصلا لازم نیست درگیر پیچیدگی‌های ارتباطی لایه‌ی بکند بشیم. اینکه اصلا سرور داریم، http server هست چیه ، کلا درگیر اینا نمیشیم.فقط درگیر نوشتن functionality ها هستیم.
اصلا اینطوری به قضیه نگاه میکنیم که میخوایم یک cli app بنویسیم که میتونینم از طریق Cli بهش ورودی بدیم و ازش خروجی بخوایم.
-----------------
توجه بشه که موجودیت‌ها بلا استثنا باید id یکتا داشته باشند.
مثلا خیلی ساده بخوایم نگاه کنیم اگه بخوایم id را از کاربر بگیریم، باید پس ذهنمون باشه که id یکتا باشه، لذا به نظر میاد شاید همون ایمیل یا کد ملی اگه از کاربر بگیریم، میتونیم یکی از همینا را بزاریم برای id کاربر، در واقع در id نگرانی ما صرفا یکتا بودن هست، و باید مطمئن باشیم که چیزی که داریم به عنوان id لحاظ میکنیم برای همه ی کاربرها یکتا باشه. 
یک کار جالبتر این هست که مثلا len لیست کاربران + 1 را بزاریم به عنوان ID
-----------------
وقتی registerd را پیاده کردیم و بعد خواستیم لاگین را پیاده کنیم. درک کردیم که یک storage layer نیازمند هستیم. که بالاخره کاربرهایی که  registerd میشن را ذخیره کنیم.
در واقع داریم صرفا تو همون برنامه تو اسلایس میریزیم و وقتی دوباره اجراش میکنیم پاک میشه، خیلی رو مخه. باید یه جا ذخیره‌اش کنیم.
-----------------
استراکت‌هاتون را مثلا استراکت user ترجیحا با حروف بزرگ تعریف کنید، که اون بحث exported را داشته باشیم که پکیج های دیگه هم بتونن از این استراکت استفاده کنند.
-----------------
لیست کاربران را به شکل global در سطح پکیج تعریف کرد، چون خارج از تابع main و توابع دیگه تعریف شده. و لذا همه جا قابل دسترسی هست. اگر با حرف کوچیک تعریف کنیم، فقط داخل پکیجی که تعریفش کردم، قابل دسترس هست، اگر با حرف بزرگ تعریف شد، exported میشه و خارج این پکیج توسط پکیج‌های دیگه هم قابل دسترسی خواهد بود.
-----------------
در هر اسکوپ از جایی که متغیر تعریف میشود تا پایان اون اسکوپ، اون متغیر یا تابع در دسترسی خواهد بود.
-----------------
در چاپ کردن اگر میخوای خودش تایپ را تشخیص بده از v% استفاده کن، و اگر میخوای مثلا اگه تایپ استراکت هست، بیاد اسم فیلدها را بده بیا از v+% استفاده کن.
-----------------
پوینتر به استراکت تعریف کرد، برای اینکه بتونه خالی بودن استراکت را به کمک nil تشخیص بده، در واقع اگه پوینتر به جایی اشاره بکند، دیگه nil نخواهدبود، ولی تا زمانی که کاربری لاگین نکرده و پوینتر به جایی اشاره نمیکند، پوینتر به استراکت nil خواهد بود.
-----------------
هر جا return یا break میخواید بزنید یک خط خالی قبلش بزارید که تو چشم تر باشه.
-----------------
این که اومد کامند و یه تابع جدا براش زد که بعد اگه هم موفق login نشد، return خالی میکرد و از تابع میمد بیرون و ادامش اجرا نمیشد خیلی خوب بود، اگه دقت کنی خودم که داشتم میزدم چون تو main بود نمیتونستم return به کار ببرم مجبور بودم از دستور continue استفاده کنم که برای اونم تازه باید میرفتم شرط و چک میکرد و کلا اضافه کاری بود.
-----------------
نام متغیرها را وابسته به اسکوپشون میتونی تعیین کنی یعنی اگه تو یه اسکوپ کوچیکی تعریف میشن که با چشم قابل رصد کردنه اسم بلندم نزاشتی نزاشتی مثل مثلا i که واسه for loop میزاری البته همین for loop اگه خیلی بلنده و تو بخشهاش هی داری از i استافده میکنی بهتره i بامسماتر باشه، کلا زمان حیات متغیر در اسمش موثره
-----------------
شروع interface  در پروژه:
میخوایم بررسی کنیم که از interface کجاها میشه استفاده کرد، که ماژول‌های مختلف کدمون از هم de couple بشند چون این دیکاپل کردن ماژولها، کمک میکنه که تعویض هر ماژولی راحت‌تر باشه، بدون اینکه روی ماژول‌های دیگه تاثیر بزاره.

interface?
Save
Read

interface Storage layaer
type storageLayer

type assertion

interface error


زمانی که کد ما کارایی لازم را دارد و اهدافی که داریم را انجام میدهد، حالا زمان آن رسیده است که refactor کنیم، یعنی کدمون را با ساختار جدید ولی با همان functionality داشته باشیم.

اول یک interface برای storage user ایجاد کردیم، یعنی قراردادی برای ذخیره‌ی کاربران (اینکه enitity user امون را چطور اطلاعاتش را store کنیم) و در واقع اینکه کجا store کنیم و چطور store کنیم را abstract کردیم، و در واقع در main اومدیم گفتیم به ما ربطی نداره که این اطلاعات user من کجا و چطوری ذخیره میشند و من صرفا یک سری رفتار مدنظرم هست که ارضا بشه که بتونم اون هدفم یعنی ذخیره‌ی اطلاعات کاربران را تضمین کنم.

در قدم بعدی تایپی تعریف کردیم به اسم fileStore که شرایط قرارداد را میتونست ارضا کنه

در قدم بعدی تمامی متود ها و پراپرتی‌های این fileStore را برداشتیم بردیم خارج از main و در یک پکیج جدید قراردادیم، با این کار ما الان یک پکیجی داریم که قرارداد main ما را ارضا میکنه و روشش هم این هست که اطلاعات کاربران ما را داخل یک فایل بر اساس روش serialization ای که خودمون بهش پاس میدیم ذخیره میکنه، و هر زمان هم بخوایم به ما اطلاعات کاربران را برمیگردونه.
مسلما هزارتا روش دیگه هم میشه به کار برد، مثل اینکه به جای ذخیره در فایل، اطلاعات را در دیتابیس ذخیره کنیم، و اینجا هم باز همون داستانه یعنی اگه خواستیم اینکارم انجام بدیم کافیه یک پکیج جدید تعریف کنیم که هدفش ذخیره‌ی اطلاعات در دیتابیس هست، و خب برای اینکه این پکیج به کار ما بیاد و به صورت دقیقتر این مدل(تایپ) برای main ما کاربرد داشته باشه، باید قراردادی که تعریف کردیم را مثل همون fileStore قبلی رعایت بکنه

گام بعد مجبور شدیم entity user را هم از main خارج کنیم و در یک پکیج جدیدی مثل entity قرار بدیم، دلیلش: ما داخل fileStore به user نیاز داشتیم، اگه تایپ user قرار بود در main بمونه باید main.user را داخل fileStore میاوردم، از طرفی  چون داخل main میخواستم از پکیج fileStore استفاده کنم، در این صورت import cyclic ایجاد میشد یا دوار، در واقع اون اونو import کرده بود، این اونو. یعنی من تو main بیام fileStore را import کنم در fileStore هم بیام main را import کنم، لذا بیخیال این قضیه شدم و user را یک پکیج جدا کردم، که هم تو main هم تو fileStore استفاده کنم، و دیگه لازم نباشه داخل fileStore بیام و mian را import کنم. و همون که mian میاد و fileStoer را import میکنه ما را بس است.


÷÷÷÷÷÷÷÷÷ تمرین‌ها
برای محاسبه‌ی باقی‌مانده هم از % هم از math.Mod میشه استفاده کرد.
-------------------
اگر رشته تماما عددی باشد، داخل if اجرا میشه:
if _, err := strconv.Atoi(ye_string); err == nil {
	pass
}ا
-------------------
خب left-padded zero 
fmt.Sprintf("%02d:%02d", c.Hour, c.Min)
اگر 3 بشه مینویسه 03 اگر 23 باشه همونو مینویسه
-------------------
چطور ببینیم یک فایل وجود داره یا نه
https://www.educative.io/answers/how-to-check-if-a-file-exists-in-golang
------------------- 

