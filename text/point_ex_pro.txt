÷÷÷÷÷÷÷÷÷ پروژه‌ی agency
بهتره که اسم پکیجها جمع نباشند.
اگه چندتا اسم هست همه را به هم بچسبون و با همون حروف کوچیک : arminjafarpisheh
-----------------
اسم فایلها همگی با حروف کوچیک باشند
-----------------
ترجیح این هست اسم پکیج و اسم فولدرش با هم یکسان باشند.
-----------------
مدل و entity خیلی جاها با هم تفاوتی ندارند اما بهتره تفاوتشون را بدونی:
توجه کن مثلا در دیتابیس ما افزون بر مقادیر، احتمالا متغیرهایی مثل createdAt , UpdatedAt هم داریم که زمان نوشتن در دیتابیس و... هست خب اگه بخوایم مدلی طراحی کنیم باید منطبق باشه با اون دیتابیسی که میخوایم باهاش کار کنیم. در صورتی که من در لاجیک خود برنامه ام اصن از این دو تا برای نمونه هیچ استفاده ای ندارم و لازم نبود اضافه بشه. لذا در اینجاها ما میایم مدل تعریف میکنیم که ممکنه یه سری فیلدهای بیشتری نسبت به entity اصلی موجود در برنامه امون داشته باشه و برای ارتبطا با دیتابیس برای نمونه خواهد بود.
و یک entity model خواهیم داشت که موجودیتی هست که در برنامه پیاده کردیم و بهش احتیاج داریم و دقیقا چیزهایی هست که در لاجیک برنامه بهشون احتیاج داریم و لازم نیست دیگه چیزهای اضافه‌ای مثل crreatedAt داخلش اضافه بزاریم.
لذا این میشه تفاوت مدل و entity 
لذا توصیه میشه همه جا همون entity را بزاریم که میشه هسته‌ای ترین موجودیت های من که بیزینس لاجیک هول محور اونها قرار داره.
-----------------
هنگام نوشتن متود، واسه قبل نام تابع که داری برای استراکت مربوطه مینویسی، بهتره که اسم کوتاه بزاری چون متودی که مینویسی برای این استراکت هست و کل فضایی که کار میکنه تو همین اسکوپ هست، لذا مثلا:
func (s *Storage) Write(data byte) errorr
همین s کافیه.
-----------------
مهمه: بستن فایل که خیلی مهمه 
اما خب عموما بستن فایل را با defer انجام میدیم.
مشکل اینجاست چون defer file.Close میزاری، اگه احیانا ()file.Close به خطا بخوره، هندل نمیتونی بکنیش، یک راه برای حل این مشکل روش زیر هست:
defer func(){
	err := file.Close()
	if err != nil {
		fmt.Printf("cant close file:%v, err)
}()
الان با این روش از defer کمک گرفتی، وقتی نوبت به defer برسه، تابع func هم تعریف و به خاطر () که اخر کار گذاشتیم، تابع اجرا هم خواهد شد. و در صورتی که file.Close با خطا مواجه بشه، به ما برمیگردونه.
-----------------

÷÷÷÷÷÷÷÷÷ پروژه‌ی toDoList

در قدم اول اصلا لازم نیست درگیر پیچیدگی‌های ارتباطی لایه‌ی بکند بشیم. اینکه اصلا سرور داریم، http server هست چیه ، کلا درگیر اینا نمیشیم.فقط درگیر نوشتن functionality ها هستیم.
اصلا اینطوری به قضیه نگاه میکنیم که میخوایم یک cli app بنویسیم که میتونینم از طریق Cli بهش ورودی بدیم و ازش خروجی بخوایم.
-----------------
توجه بشه که موجودیت‌ها بلا استثنا باید id یکتا داشته باشند.
مثلا خیلی ساده بخوایم نگاه کنیم اگه بخوایم id را از کاربر بگیریم، باید پس ذهنمون باشه که id یکتا باشه، لذا به نظر میاد شاید همون ایمیل یا کد ملی اگه از کاربر بگیریم، میتونیم یکی از همینا را بزاریم برای id کاربر، در واقع در id نگرانی ما صرفا یکتا بودن هست، و باید مطمئن باشیم که چیزی که داریم به عنوان id لحاظ میکنیم برای همه ی کاربرها یکتا باشه. 
یک کار جالبتر این هست که مثلا len لیست کاربران + 1 را بزاریم به عنوان ID
-----------------
وقتی registerd را پیاده کردیم و بعد خواستیم لاگین را پیاده کنیم. درک کردیم که یک storage layer نیازمند هستیم. که بالاخره کاربرهایی که  registerd میشن را ذخیره کنیم.
در واقع داریم صرفا تو همون برنامه تو اسلایس میریزیم و وقتی دوباره اجراش میکنیم پاک میشه، خیلی رو مخه. باید یه جا ذخیره‌اش کنیم.
-----------------
استراکت‌هاتون را مثلا استراکت user ترجیحا با حروف بزرگ تعریف کنید، که اون بحث exported را داشته باشیم که پکیج های دیگه هم بتونن از این استراکت استفاده کنند.
-----------------
لیست کاربران را به شکل global در سطح پکیج تعریف کرد، چون خارج از تابع main و توابع دیگه تعریف شده. و لذا همه جا قابل دسترسی هست. اگر با حرف کوچیک تعریف کنیم، فقط داخل پکیجی که تعریفش کردم، قابل دسترس هست، اگر با حرف بزرگ تعریف شد، exported میشه و خارج این پکیج توسط پکیج‌های دیگه هم قابل دسترسی خواهد بود.
-----------------
در هر اسکوپ از جایی که متغیر تعریف میشود تا پایان اون اسکوپ، اون متغیر یا تابع در دسترسی خواهد بود.
-----------------
در چاپ کردن اگر میخوای خودش تایپ را تشخیص بده از v% استفاده کن، و اگر میخوای مثلا اگه تایپ استراکت هست، بیاد اسم فیلدها را بده بیا از v+% استفاده کن.
-----------------
پوینتر به استراکت تعریف کرد، برای اینکه بتونه خالی بودن استراکت را به کمک nil تشخیص بده، در واقع اگه پوینتر به جایی اشاره بکند، دیگه nil نخواهدبود، ولی تا زمانی که کاربری لاگین نکرده و پوینتر به جایی اشاره نمیکند، پوینتر به استراکت nil خواهد بود.
-----------------
هر جا return یا break میخواید بزنید یک خط خالی قبلش بزارید که تو چشم تر باشه.
-----------------
این که اومد کامند و یه تابع جدا براش زد که بعد اگه هم موفق login نشد، return خالی میکرد و از تابع میمد بیرون و ادامش اجرا نمیشد خیلی خوب بود، اگه دقت کنی خودم که داشتم میزدم چون تو main بود نمیتونستم return به کار ببرم مجبور بودم از دستور continue استفاده کنم که برای اونم تازه باید میرفتم شرط و چک میکرد و کلا اضافه کاری بود.
-----------------
نام متغیرها را وابسته به اسکوپشون میتونی تعیین کنی یعنی اگه تو یه اسکوپ کوچیکی تعریف میشن که با چشم قابل رصد کردنه اسم بلندم نزاشتی نزاشتی مثل مثلا i که واسه for loop میزاری البته همین for loop اگه خیلی بلنده و تو بخشهاش هی داری از i استافده میکنی بهتره i بامسماتر باشه، کلا زمان حیات متغیر در اسمش موثره
-----------------
شروع interface  در پروژه:
میخوایم بررسی کنیم که از interface کجاها میشه استفاده کرد، که ماژول‌های مختلف کدمون از هم de couple بشند چون این دیکاپل کردن ماژولها، کمک میکنه که تعویض هر ماژولی راحت‌تر باشه، بدون اینکه روی ماژول‌های دیگه تاثیر بزاره.

زمانی که کد ما کارایی لازم را دارد و اهدافی که داریم را انجام میدهد، حالا زمان آن رسیده است که refactor کنیم، یعنی کدمون را با ساختار جدید ولی با همان functionality داشته باشیم.

اول یک interface برای storage user ایجاد کردیم، یعنی قراردادی برای ذخیره‌ی کاربران (اینکه enitity user امون را چطور اطلاعاتش را store کنیم) و در واقع اینکه کجا store کنیم و چطور store کنیم را abstract کردیم، و در واقع در main اومدیم گفتیم به ما ربطی نداره که این اطلاعات user من کجا و چطوری ذخیره میشند و من صرفا یک سری رفتار مدنظرم هست که ارضا بشه که بتونم اون هدفم یعنی ذخیره‌ی اطلاعات کاربران را تضمین کنم.

در قدم بعدی تایپی تعریف کردیم به اسم fileStore که شرایط قرارداد را میتونست ارضا کنه

در قدم بعدی تمامی متود ها و پراپرتی‌های این fileStore را برداشتیم بردیم خارج از main و در یک پکیج جدید قراردادیم، با این کار ما الان یک پکیجی داریم که قرارداد main ما را ارضا میکنه و روشش هم این هست که اطلاعات کاربران ما را داخل یک فایل بر اساس روش serialization ای که خودمون بهش پاس میدیم ذخیره میکنه، و هر زمان هم بخوایم به ما اطلاعات کاربران را برمیگردونه.
مسلما هزارتا روش دیگه هم میشه به کار برد، مثل اینکه به جای ذخیره در فایل، اطلاعات را در دیتابیس ذخیره کنیم، و اینجا هم باز همون داستانه یعنی اگه خواستیم اینکارم انجام بدیم کافیه یک پکیج جدید تعریف کنیم که هدفش ذخیره‌ی اطلاعات در دیتابیس هست، و خب برای اینکه این پکیج به کار ما بیاد و به صورت دقیقتر این مدل(تایپ) برای main ما کاربرد داشته باشه، باید قراردادی که تعریف کردیم را مثل همون fileStore قبلی رعایت بکنه

گام بعد مجبور شدیم entity user را هم از main خارج کنیم و در یک پکیج جدیدی مثل entity قرار بدیم، دلیلش: ما داخل fileStore به user نیاز داشتیم، اگه تایپ user قرار بود در main بمونه باید main.user را داخل fileStore میاوردم، از طرفی  چون داخل main میخواستم از پکیج fileStore استفاده کنم، در این صورت import cyclic ایجاد میشد یا دوار، در واقع اون اونو import کرده بود، این اونو. یعنی من تو main بیام fileStore را import کنم در fileStore هم بیام main را import کنم، لذا بیخیال این قضیه شدم و user را یک پکیج جدا کردم، که هم تو main هم تو fileStore استفاده کنم، و دیگه لازم نباشه داخل fileStore بیام و mian را import کنم. و همون که mian میاد و fileStoer را import میکنه ما را بس است.
-----------------
کجا قرار داریم؟
فیلم ۱.کلاینت سرور، جلسه نهم
تا الان یه سری کامند براش نوشتیم که بخشی از  نیازمندی‌هامون را پوشش میده.

قدم بعدی این بود که بحث حافظه داشتن مطرح کردیم، گفتیم نیمشه هر یوزری بیاد یه سری کار انجام بده ، بعد برنامه بسته شه ، هر چی اطلاعات داشت پاک شه، و لذا گفتیم نیاز به حافظه داریم و برای این کار ذخیره و بازیابی از فایل را در نظر گرفتیم

بحث اینکه با چه فرمتی ذخیره کنیم و در واقع serialization ما به چه صورت باشه را هم انجام دادیم. و لذا فرمت ذخیره سازی میتوانست توسط کاربر انتخاب بشه و داده های کاربران طبق همون فرمت ذخیره بشند.

در گام بعدی گفتیم کدمون خیلی کثیف هست، چون صرفا یک main داشتیم و کل لاجیک در این main پیاده شده بود. لذا ساختار بندی کردیم پروژه.
در حین همین گام سعی کردیم با اضافه کردن interface و در واقع بخش contract به پروژه، وابستگی ها را هم کاهش دهیم - که برای نمونه هم لایه‌ی storage را همین کار را کردیم و در نهایت برنامه‌ی ما از لایه‌ی storage جدا شد، و هر نوع حافظه‌ای که الزمات و یا قرارداد ما را رعایت کنه به عنوان storage ما مناسب خواهد بود. 


اما مشکلات فعلی:
۱. این اپی که زدیم را نمیتونیم بدیم به کاربران مختلف که روی سیستمشون اجرا کنند.
چرا؟ هر کسی این اپ را در سیستم خودش اجرا کند، دیتا روی همون سیستم ذخیره خواهد این دیتا میتونه user.txt , task.txt , category.txt باشه، تمامی دیتاهای هر کاربر در سیستم خودش ذخیره خواهد شد.
اگر دیتاها بین کاربران یکسان و یا  سینک نباشه، هر کسی که این اپ را run کنه، نسخه‌های txt مربوط به خودش را خواهد داشت، که کاملا متفاوت با دیگر کاربران خواهد بود.
در واقع با این وضع هر کاربری صرفا دیتاهای خودش را داره و همچنین این دیتا را فقط و فقط خودش داره و کس دیگه‌ای اون را نداره (برای مثال منی که برنامه را نوشتم دسترسی به دیتای اون ندارم)
در واقع برنامه stand alone هست، این یعنی برنامه‌ای که هم کلاینت هم سرور، منظور از کلاینت:کاربر میاد با cli کار میکنه، دستور میده و پاسخ میگیره و منظور از سرور: بخشی از کد که مسئول بررسی دستورات هست، دستورات را میگیره، پردازش میکنه اگه لازم باشه ذخیره میکنه و پاسخ‌ها را پاس میدهد و در حال حاضر هر دوی این مسئولیت‌ها را یک اپ داره انجام میده. و صرفا هم در همون سیستم به صورت local انجام میده

۲. حتی برای یک یوزر هم مشکل هست، و اون portable بودن هست، یعنی همین کار بر اگه مثلا بخواد در یک دیوایس دیگه مثلا در شرکتش هم به این اپ دسترسی داشته باشه، نمیتونه، مگه اینکه لایه‌ storage را با خودش این ور اونور بکشه .

پس میخواهم این مشکلات را حل کنم. 
من میخوام یه اپ داشته باشم، که هر کسی خواست بیاد register کنه، و من به عنوان توسعه‌دهنده ببینم که کیا register کردند، چه تسکهایی ساختند چه دسته‌بندی هایی ساختند ،  کیا وصل هستند و...
در واقع باید دیتای همه‌ی کاربران متمرکز باشه، تا portable بودن اوکی بشه، در واقع با این کار کاربر دیگه درگیر بحث ذخیره‌سازی و اینا نمیشه، کافیه بیاد درخواست بده و بعد جوابشو بگیره و بره، و اینکار را در هر دیوایسی که خواست انجام بده. ضمن این که من هم به عنوان توسعه‌دهنده بتوانم آگاهی نسبت به وضعیت کاربران استفاده کننده داشته باشم.

ایده‌ی ۱: اقا این اپو بدیم به هر کسی ، همین اپی که هم سرور هست هم کلاینت، فقط بگیم باید فایلهای ذخیره‌سازی کلیه‌ی کاربران باید با هم سینک باشند، در واقع هر کسی هر وقت داده‌ای نوشت، سریعا به همه بگه،‌همه برن جدیدترین نسخه‌ی داده‌های txt را مثلا بگیرند(با فرض اینکه فایل هست) ممنکه دیتابیس باشه اصن، خب مشکلات این راه حل هم واضح هست دیگه، اصن چرا کاربر باید دغدغه‌ی بکگراند برنامه را داشته باشه، یا اگه هم بخوایم خودکار اون پشت اینکارها صورت بگیره، و خود کاربر در جریان نباشه، چطوری این سینک بودنو اوکی کنیم، بحث کانفیلیکت بین اطلاعات یکسان ، مثلا ایدی یکسان و ... چطوری مدیریت بشه و هزاران مشکل
فقط خوبیش اینه دست به اپ نمیزنیم و همه کثافت کاری ها میشه ارتباط بین این لایه‌ storage ها با هم ولی خب به این سادگی نیست، ساده‌ترینش مثلا بحث ایدی ها هست که هر اپی داره نسبت به خودش میره جلو و کلا مشکل هست این روش - پس روش متمرکز کردن لایه‌ی storage به هر روشی اصلا ایده‌ی خوبی نیست

ایده‌ی ۲: روش دیگه این هست لاجیک های سمت سرور که صحت‌سنجی و ذخیره‌سازی و بررسی ورودی کاربر و دادن خروجی مناسب پس از صحت سنجی وی و... همه‌ی اینها را جدا کنیم، و به عنوان یک اپ جدا ببینیمش
از اونطرف اون بخشی که کلاینت هست و کاربر قرار هست لاگین کنه،‌ ورودی و دستور بده، و انتظار جواب از ما داره و باید بهش در فرمت مناسبی نمایش بدیم را یک برنامه‌ی جدا ببینیم
و در بحث ارتباط این دو اپ با هم: اگر روی یک سیستم باشند هر دو اپ دو تا فایل مشخص در همون سیستم که هر دو بهش دسترسی دارن در نظر میگیریم، ابتدا یک فایل مشخصی مثل request.txt در نظر میگریم، کلاینت دستوراتش را در این فایل رایت میکنه، سرور میاد هر به چند وقت این فایل را میخونه و دستورات را پردازش و خروجی را اماده میکنه، یک فایل دیگه هم هست به اسم response.txt که سرور خروجی‌هایی که اماده کرده را داخلش مینویسه، و کلاینت هم برای رسیدن به جوابهاش هر به چند وقت میاد این فایل را میخونه و به جواباش میرسه

ایده‌ی ۳: مثل ایده‌ی ۲ فقط بحث ارتباط اپ ها با هم باید اصلاح بشه.
روی یک سیستم بودن که دردسر های خودش را داره، هر به چند وقت داده بببینیم، تعداد درخواستها زیاد نشه و کلی چالش دیگه و برای یک سیستم هم این روش خوب نیست
اگه هم بخواد دو تا اپ روی سیستمهای جدا باشند، که دیگه فایل یکسانی مثل  request.txt , reponse.txt وجود نداره که بخوان بخونن یا توش بنویسیند. و اصلا نشدنی میشه
راه‌حل : ارتباط از طریق اینترنت یا network یا شبکه هست،‌ هر سیستمی اگر به اینترنت متصل بشه ایپی مشخصی خواهد داشت، در این صورت ما به عنوان کلاینت قادر خواهیم بود به ادرس سرور متصل بشیم و درخواست برفرستیم و response را هم بعد دریافت کنیم.


شروع به ریفکتور برای جدا کردن کلاینت و سرور 
خیلی از جاهایی برنامه، الان این دو کاملا با هم کاپل شدند، برای مثال در create task عملا این دو کاملا در هم تنیده هستند چرا که ورودی‌ای که این تابع قرار هست میگیره، در همین برنامه اتفاق میفته در حالی که ساخت task اساسا یک وظیفه‌ی سرور هست ولی کلاینت باید اطلاعات تسکی که مدنظر دارد را برای سرور ارسال کند.
یک پوشه‌ی سرویس میسازیم و سرویس های سمت سرور را شروع میکنیم یکی یکی پیاده کردن.
ابتدا برای task میسازم

بحث این که تابع create task ای که پیاده کردیم، entity.Task برگردونه یا CreatedTaskResponse  

منظور از repository ای که در task struct تعریف شده، توابعی هستند که برای پیش‌برد کارمون بهشون نیاز داریم. در واقع Task الان به شکلی پیاده شده است که متودهای مورد نیازش در repository قرار داره.

جاهایی که ابجکتی که قرار هست پاس بدیم بزرگ هست، بهتره پوینتر پاس بدیم به جای اینکه مقدارشو هی کپی کنیم، در این صورت ادرس میره و این مشکل جابه‌جایی اشیا بزرگ حل میشه.


بعد از جنجال فیلم ۵ جلسه ۹، حالا در فیلم ۷ هدف این هست که کلاینت را یک برنامه‌ی جدا دیگه ببینیمش و کلا هر دوی کلاینت و سرور  یک جا نباشند.

خب اومدیم و سرور را بخشیش را از کلاینت جدا کردیم، که درخواست را میگیره و پردازش میکنه به این صورت که :
الان یک کلاینت داریم و یک سرور که پروتکل commiunication اشون tcp هستش و فرمت رد و بدل کردن دیتاشون هم json هستش. دقیقا اتفاقی که در http server ها برای rest api میفته. فریمورک های مختلفی مثل echo , gin و هر وب فریمورکی دیگه‌ای هم داره از همین استفاده میکنه، یعنی داره یک tcp server راه اندازی میکنه که دیتایی با فرمت json را به عنوان ورودی میپذیره و خروجیش را هم با فرمت json پاس میده. 
در نظر بگیرید که کدی که داریم اوکیه ولی خب خیلی ملاحضات درش لحاظ نشده و برای همین سراغ پیاده‌سازی های دیگه هم میریم و گرنه اصل کار همین اتفاقات رقم میخوره. برای مثال یکیش میتونه این باشه که شروع ارتباط لزوما با ارسال درخواست از سمت کلاینت و این شکل req res ای نیست، یعنی ممکنه سرور اطلاعاتی را ارسال کنه و... یا مثلا secure کردن ارتباط را ما هندل نمیکنیم و هر درخواست بین کلاینت و سرور به صورت پلین داره ارسال میشه.

افزایش deleivery param 
قسمت service : اضافه کردن category service , user service
کامل کردن قسمت storage
در حدی که کامندهایی که اول میزدیم کامل بشه

÷÷÷÷÷÷÷÷÷ تمرین‌ها
برای محاسبه‌ی باقی‌مانده هم از % هم از math.Mod میشه استفاده کرد.
-------------------
اگر رشته تماما عددی باشد، داخل if اجرا میشه:
if _, err := strconv.Atoi(ye_string); err == nil {
	pass
}ا
------------------
خب left-padded zero 
fmt.Sprintf("%02d:%02d", c.Hour, c.Min)
اگر 3 بشه مینویسه 03 اگر 23 باشه همونو مینویسه
-------------------
چطور ببینیم یک فایل وجود داره یا نه
https://www.educative.io/answers/how-to-check-if-a-file-exists-in-golang
------------------- 

