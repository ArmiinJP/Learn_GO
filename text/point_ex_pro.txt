÷÷÷÷÷÷÷÷÷ پروژه‌ی agency
بهتره که اسم پکیجها جمع نباشند.
اگه چندتا اسم هست همه را به هم بچسبون و با همون حروف کوچیک : arminjafarpisheh
-----------------
اسم فایلها همگی با حروف کوچیک باشند
-----------------
ترجیح این هست اسم پکیج و اسم فولدرش با هم یکسان باشند.
-----------------
مدل و entity خیلی جاها با هم تفاوتی ندارند اما بهتره تفاوتشون را بدونی:
توجه کن مثلا در دیتابیس ما افزون بر مقادیر، احتمالا متغیرهایی مثل createdAt , UpdatedAt هم داریم که زمان نوشتن در دیتابیس و... هست خب اگه بخوایم مدلی طراحی کنیم باید منطبق باشه با اون دیتابیسی که میخوایم باهاش کار کنیم. در صورتی که من در لاجیک خود برنامه ام اصن از این دو تا برای نمونه هیچ استفاده ای ندارم و لازم نبود اضافه بشه. لذا در اینجاها ما میایم مدل تعریف میکنیم که ممکنه یه سری فیلدهای بیشتری نسبت به entity اصلی موجود در برنامه امون داشته باشه و برای ارتبطا با دیتابیس برای نمونه خواهد بود.
و یک entity model خواهیم داشت که موجودیتی هست که در برنامه پیاده کردیم و بهش احتیاج داریم و دقیقا چیزهایی هست که در لاجیک برنامه بهشون احتیاج داریم و لازم نیست دیگه چیزهای اضافه‌ای مثل crreatedAt داخلش اضافه بزاریم.
لذا این میشه تفاوت مدل و entity 
لذا توصیه میشه همه جا همون entity را بزاریم که میشه هسته‌ای ترین موجودیت های من که بیزینس لاجیک هول محور اونها قرار داره.
-----------------
هنگام نوشتن متود، واسه قبل نام تابع که داری برای استراکت مربوطه مینویسی، بهتره که اسم کوتاه بزاری چون متودی که مینویسی برای این استراکت هست و کل فضایی که کار میکنه تو همین اسکوپ هست، لذا مثلا:
func (s *Storage) Write(data byte) errorr
همین s کافیه.
-----------------
مهمه: بستن فایل که خیلی مهمه 
اما خب عموما بستن فایل را با defer انجام میدیم.
مشکل اینجاست چون defer file.Close میزاری، اگه احیانا ()file.Close به خطا بخوره، هندل نمیتونی بکنیش، یک راه برای حل این مشکل روش زیر هست:
defer func(){
	err := file.Close()
	if err != nil {
		fmt.Printf("cant close file:%v, err)
}()
الان با این روش از defer کمک گرفتی، وقتی نوبت به defer برسه، تابع func هم تعریف و به خاطر () که اخر کار گذاشتیم، تابع اجرا هم خواهد شد. و در صورتی که file.Close با خطا مواجه بشه، به ما برمیگردونه.
-----------------

÷÷÷÷÷÷÷÷÷ پروژه‌ی toDoList

در قدم اول اصلا لازم نیست درگیر پیچیدگی‌های ارتباطی لایه‌ی بکند بشیم. اینکه اصلا سرور داریم، http server هست چیه ، کلا درگیر اینا نمیشیم.فقط درگیر نوشتن functionality ها هستیم.
اصلا اینطوری به قضیه نگاه میکنیم که میخوایم یک cli app بنویسیم که میتونینم از طریق Cli بهش ورودی بدیم و ازش خروجی بخوایم.
-----------------
توجه بشه که موجودیت‌ها بلا استثنا باید id یکتا داشته باشند.
مثلا خیلی ساده بخوایم نگاه کنیم اگه بخوایم id را از کاربر بگیریم، باید پس ذهنمون باشه که id یکتا باشه، لذا به نظر میاد شاید همون ایمیل یا کد ملی اگه از کاربر بگیریم، میتونیم یکی از همینا را بزاریم برای id کاربر، در واقع در id نگرانی ما صرفا یکتا بودن هست، و باید مطمئن باشیم که چیزی که داریم به عنوان id لحاظ میکنیم برای همه ی کاربرها یکتا باشه. 
یک کار جالبتر این هست که مثلا len لیست کاربران + 1 را بزاریم به عنوان ID
-----------------
وقتی registerd را پیاده کردیم و بعد خواستیم لاگین را پیاده کنیم. درک کردیم که یک storage layer نیازمند هستیم. که بالاخره کاربرهایی که  registerd میشن را ذخیره کنیم.
در واقع داریم صرفا تو همون برنامه تو اسلایس میریزیم و وقتی دوباره اجراش میکنیم پاک میشه، خیلی رو مخه. باید یه جا ذخیره‌اش کنیم.
-----------------
استراکت‌هاتون را مثلا استراکت user ترجیحا با حروف بزرگ تعریف کنید، که اون بحث exported را داشته باشیم که پکیج های دیگه هم بتونن از این استراکت استفاده کنند.
-----------------
لیست کاربران را به شکل global در سطح پکیج تعریف کرد، چون خارج از تابع main و توابع دیگه تعریف شده. و لذا همه جا قابل دسترسی هست. اگر با حرف کوچیک تعریف کنیم، فقط داخل پکیجی که تعریفش کردم، قابل دسترس هست، اگر با حرف بزرگ تعریف شد، exported میشه و خارج این پکیج توسط پکیج‌های دیگه هم قابل دسترسی خواهد بود.
-----------------
در هر اسکوپ از جایی که متغیر تعریف میشود تا پایان اون اسکوپ، اون متغیر یا تابع در دسترسی خواهد بود.
-----------------
در چاپ کردن اگر میخوای خودش تایپ را تشخیص بده از v% استفاده کن، و اگر میخوای مثلا اگه تایپ استراکت هست، بیاد اسم فیلدها را بده بیا از v+% استفاده کن.
-----------------
پوینتر به استراکت تعریف کرد، برای اینکه بتونه خالی بودن استراکت را به کمک nil تشخیص بده، در واقع اگه پوینتر به جایی اشاره بکند، دیگه nil نخواهدبود، ولی تا زمانی که کاربری لاگین نکرده و پوینتر به جایی اشاره نمیکند، پوینتر به استراکت nil خواهد بود.
-----------------
هر جا return یا break میخواید بزنید یک خط خالی قبلش بزارید که تو چشم تر باشه.
-----------------
این که اومد کامند و یه تابع جدا براش زد که بعد اگه هم موفق login نشد، return خالی میکرد و از تابع میمد بیرون و ادامش اجرا نمیشد خیلی خوب بود، اگه دقت کنی خودم که داشتم میزدم چون تو main بود نمیتونستم return به کار ببرم مجبور بودم از دستور continue استفاده کنم که برای اونم تازه باید میرفتم شرط و چک میکرد و کلا اضافه کاری بود.
-----------------
نام متغیرها را وابسته به اسکوپشون میتونی تعیین کنی یعنی اگه تو یه اسکوپ کوچیکی تعریف میشن که با چشم قابل رصد کردنه اسم بلندم نزاشتی نزاشتی مثل مثلا i که واسه for loop میزاری البته همین for loop اگه خیلی بلنده و تو بخشهاش هی داری از i استافده میکنی بهتره i بامسماتر باشه، کلا زمان حیات متغیر در اسمش موثره
-----------------



÷÷÷÷÷÷÷÷÷ تمرین‌ها
برای محاسبه‌ی باقی‌مانده هم از % هم از math.Mod میشه استفاده کرد.
-------------------
اگر رشته تماما عددی باشد، داخل if اجرا میشه:
if _, err := strconv.Atoi(ye_string); err == nil {
	pass
}ا
-------------------
خب left-padded zero 
fmt.Sprintf("%02d:%02d", c.Hour, c.Min)
اگر 3 بشه مینویسه 03 اگر 23 باشه همونو مینویسه
-------------------
چطور ببینیم یک فایل وجود داره یا نه
https://www.educative.io/answers/how-to-check-if-a-file-exists-in-golang
------------------- 

